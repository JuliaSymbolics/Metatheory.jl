<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl 1.0</a></li><li><a class="tocitem" href="../rewrite/">Classical Term Rewriting</a></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../interface/">Interfacing with Metatheory.jl</a></li><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Patterns"><span>Patterns</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Rules-2"><span>Rules</span></a></li><li><a class="tocitem" href="#Rewriters"><span>Rewriters</span></a></li><li><a class="tocitem" href="#EGraphs"><span>EGraphs</span></a></li><li><a class="tocitem" href="#EGraph-Schedulers"><span>EGraph Schedulers</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.rewrite_rhs-Tuple{Expr}" href="#Metatheory.Syntax.rewrite_rhs-Tuple{Expr}"><code>Metatheory.Syntax.rewrite_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rewrite_rhs(expr::Expr)</code></pre><p>Rewrite the <code>expr</code> by dealing with <code>:where</code> if necessary. The <code>:where</code> is rewritten from, for example, <code>~x where f(~x)</code> to <code>f(~x) ? ~x : nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Syntax.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.rmlines-Tuple{Expr}" href="#Metatheory.Syntax.rmlines-Tuple{Expr}"><code>Metatheory.Syntax.rmlines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove LineNumberNode from quoted blocks of code</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Syntax.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@capture-Tuple" href="#Metatheory.Syntax.@capture-Tuple"><code>Metatheory.Syntax.@capture</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@capture ex pattern</code></pre><p>Uses a <code>Rule</code> object to capture an expression if it matches the <code>pattern</code>. Returns <code>true</code> and injects slot variable match results into the calling scope when the <code>pattern</code> matches, otherwise returns false. The rule language for specifying the <code>pattern</code> is the same in @capture as it is in <code>@rule</code>. Contextual matching is not yet supported</p><pre><code class="language-julia">julia&gt; @syms a; ex = a^a;
julia&gt; if @capture ex (~x)^(~x)
           @show x
       elseif @capture ex 2(~y)
           @show y
       end;
x = a</code></pre><p>See also: <a href="#Metatheory.Syntax.@rule-Tuple"><code>@rule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Syntax.jl#L397-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@rule-Tuple" href="#Metatheory.Syntax.@rule-Tuple"><code>Metatheory.Syntax.@rule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@rule [SLOTS...] LHS operator RHS</code></pre><p>Creates an <code>AbstractRule</code> object. A rule object is callable, and takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns <code>nothing</code> otherwise. The rule language is described below.</p><p>LHS can be any possibly nested function call expression where any of the arugments can optionally be a Slot (<code>~x</code>) or a Segment (<code>~x...</code>) (described below).</p><p>SLOTS is an optional list of symbols to be interpeted as slots or segments directly (without using <code>~</code>).  To declare slots for several rules at once, see the <code>@slots</code> macro.</p><p>If an expression matches LHS entirely, then it is rewritten to the pattern in the RHS , whose local scope includes the slot matches as variables. Segment (<code>~x</code>) and slot variables (<code>~~x</code>) on the RHS will substitute the result of the matches found for these variables in the LHS.</p><p><strong>Rule operators</strong>:</p><ul><li><code>LHS =&gt; RHS</code>: create a <code>DynamicRule</code>. The RHS is <em>evaluated</em> on rewrite.</li><li><code>LHS --&gt; RHS</code>: create a <code>RewriteRule</code>. The RHS is <strong>not</strong> evaluated but <em>symbolically substituted</em> on rewrite.</li><li><code>LHS == RHS</code>: create a <code>EqualityRule</code>. In e-graph rewriting, this rule behaves like <code>RewriteRule</code> but can go in both directions. Doesn&#39;t work in classical rewriting</li><li><code>LHS ≠ RHS</code>: create a <code>UnequalRule</code>. Can only be used in e-graphs, and is used to eagerly stop the process of rewriting if LHS is found to be equal to RHS.</li></ul><p><strong>Slot</strong>:</p><p>A Slot variable is written as <code>~x</code> and matches a single expression. <code>x</code> is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by <code>isequal</code>).</p><p><em>Example:</em></p><p>Simple rule to turn any <code>sin</code> into <code>cos</code>:</p><pre><code class="language-julia">julia&gt; r = @rule sin(~x) --&gt; cos(~x)
sin(~x) --&gt; cos(~x)

julia&gt; r(:(sin(1+a)))
:(cos((1 + a)))</code></pre><p>A rule with 2 segment variables</p><pre><code class="language-julia">julia&gt; r = @rule sin(~x + ~y) --&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y)
sin(~x + ~y) --&gt; sin(~x) * cos(~y) + cos(~x) * sin(~y)

julia&gt; r(:(sin(a + b)))
:(cos(a)*sin(b) + sin(a)*cos(b))</code></pre><p>A rule that matches two of the same expressions:</p><pre><code class="language-julia">julia&gt; r = @rule sin(~x)^2 + cos(~x)^2 --&gt; 1
sin(~x) ^ 2 + cos(~x) ^ 2 --&gt; 1

julia&gt; r(:(sin(2a)^2 + cos(2a)^2))
1

julia&gt; r(:(sin(2a)^2 + cos(a)^2))
# nothing</code></pre><p>A rule without <code>~</code></p><pre><code class="language-julia">julia&gt; r = @slots x y z @rule x(y + z) --&gt; x*y + x*z
x(y + z) --&gt; x*y + x*z</code></pre><p><strong>Segment</strong>: A Segment variable matches zero or more expressions in the function call. Segments may be written by splatting slot variables (<code>~x...</code>).</p><p><em>Example:</em></p><pre><code class="language-julia">julia&gt; r = @rule f(~xs...) --&gt; g(~xs...);
julia&gt; r(:(f(1, 2, 3)))
:(g(1,2,3))</code></pre><p><strong>Predicates</strong>:</p><p>There are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both <code>~x</code> and <code>~~x</code> by using the <code>~x::f</code> or <code>~~x::f</code>. Here <code>f</code> can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.</p><p>The predicate should return <code>true</code> if the current match is acceptable, and <code>false</code> otherwise.</p><pre><code class="language-julia">julia&gt; two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) &lt; 10^-9
two_πs (generic function with 1 method)

julia&gt; two_πs(x) = false
two_πs (generic function with 2 methods)

julia&gt; r = @rule sin(~~x + ~y::two_πs + ~~z) =&gt; :(sin($(Expr(:call, :+, ~~x..., ~~z...))))
sin(~(~x) + ~(y::two_πs) + ~(~z)) --&gt; sin(+(~(~x)..., ~(~z)...))

julia&gt; r(:(sin(a+$(3π))))

julia&gt; r(:(sin(a+$(6π))))
:(sin(+a))

julia&gt; r(sin(a+6π+c))
:(sin(a + c))</code></pre><p>Predicate function gets an array of values if attached to a segment variable (<code>~x...</code>).</p><p>For the predicate over the whole rule, use <code>@rule &lt;LHS&gt; =&gt; &lt;RHS&gt; where &lt;predicate&gt;</code>:</p><pre><code class="language-none">julia&gt; predicate(x) = x === a;

julia&gt; r = @rule ~x =&gt; ~x where f(~x);

julia&gt; r(a)
a

julia&gt; r(b) === nothing
true</code></pre><p>Note that this is syntactic sugar and that it is the same as <code>@rule ~x =&gt; f(~x) ? ~x : nothing</code>.</p><p><strong>Compatibility</strong>: Segment variables may still be written as (<code>~~x</code>), and slot (<code>~x</code>) and segment (<code>~x...</code> or <code>~~x</code>) syntaxes on the RHS will still substitute the result of the matches. See also: <a href="#Metatheory.Syntax.@capture-Tuple"><code>@capture</code></a>, <a href="#Metatheory.Syntax.@slots-Tuple"><code>@slots</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Syntax.jl#L190-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@slots-Tuple" href="#Metatheory.Syntax.@slots-Tuple"><code>Metatheory.Syntax.@slots</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@slots [SLOTS...] ex</code></pre><p>Declare SLOTS as slot variables for all <code>@rule</code> or <code>@capture</code> invocations in the expression <code>ex</code>. <em>Example:</em></p><pre><code class="language-julia">julia&gt; @slots x y z a b c Chain([
    (@rule x^2 + 2x*y + y^2 =&gt; (x + y)^2),
    (@rule x^a * y^b =&gt; (x*y)^a * y^(b-a)),
    (@rule +(x...) =&gt; sum(x)),
])</code></pre><p>See also: <a href="#Metatheory.Syntax.@rule-Tuple"><code>@rule</code></a>, <a href="#Metatheory.Syntax.@capture-Tuple"><code>@capture</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Syntax.jl#L168-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@theory-Tuple" href="#Metatheory.Syntax.@theory-Tuple"><code>Metatheory.Syntax.@theory</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@theory [SLOTS...] begin (LHS operator RHS)... end</code></pre><p>Syntax sugar to define a vector of rules in a nice and readable way. Can use <code>@slots</code> or have the slots  as the first arguments:</p><pre><code class="language-none">julia&gt; t = @theory x y z begin 
    x * (y + z) --&gt; (x * y) + (x * z)
    x + y       ==  (y + x)
    #...
end;</code></pre><p>Is the same thing as writing</p><pre><code class="language-none">julia&gt; v = [
    @rule x y z  x * (y + z) --&gt; (x * y) + (x * z)
    @rule x y x + y == (y + x)
    #...
];</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Syntax.jl#L354-L377">source</a></section></article><hr/><h2 id="Patterns"><a class="docs-heading-anchor" href="#Patterns">Patterns</a><a id="Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Patterns" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.AbstractPat" href="#Metatheory.Patterns.AbstractPat"><code>Metatheory.Patterns.AbstractPat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing a pattern used in all the various pattern matching backends. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Patterns.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.PatSegment" href="#Metatheory.Patterns.PatSegment"><code>Metatheory.Patterns.PatSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p>If you want to match a variable number of subexpressions at once, you will need a <strong>segment pattern</strong>.  A segment pattern represents a vector of subexpressions matched.  You can attach a predicate <code>g</code> to a segment variable. In the case of segment variables <code>g</code> gets a vector of 0 or more  expressions and must return a boolean value. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Patterns.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.PatTerm" href="#Metatheory.Patterns.PatTerm"><code>Metatheory.Patterns.PatTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Term patterns will match on terms of the same <code>arity</code> and with the same  function symbol <code>operation</code> and expression head <code>exprhead</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Patterns.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.PatVar" href="#Metatheory.Patterns.PatVar"><code>Metatheory.Patterns.PatVar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PatVar{P}(name, debrujin_index, predicate::P)</code></pre><p>Pattern variables will first match on one subterm and instantiate the substitution to that subterm.</p><p>Matcher pattern may contain pattern variables with attached predicates, where <code>predicate</code> is a function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if <code>f</code> returns true.</p><p><code>predicate</code> can also be a <code>Type{&lt;:t}</code>, this predicate is called a  type assertion. Type assertions on a <code>PatVar</code>, will match if and only if  the type of the matched term for the pattern variable is a subtype of <code>T</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Patterns.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.isground-Tuple{AbstractPat}" href="#Metatheory.Patterns.isground-Tuple{AbstractPat}"><code>Metatheory.Patterns.isground</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A ground pattern contains no pattern variables and  only literal values to match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Patterns.jl#L24-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.patvars-Tuple{PatVar, Any}" href="#Metatheory.Patterns.patvars-Tuple{PatVar, Any}"><code>Metatheory.Patterns.patvars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collects pattern variables appearing in a pattern into a vector of symbols</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Patterns.jl#L125-L127">source</a></section></article><hr/><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.DynamicRule" href="#Metatheory.Rules.DynamicRule"><code>Metatheory.Rules.DynamicRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules defined as <code>left_hand =&gt; right_hand</code> are called <code>dynamic</code> rules. Dynamic rules behave like anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>=&gt;</code> rule is evaluated during rewriting: matched values are bound to pattern variables as in a regular function call. This allows for dynamic computation of right hand sides.</p><p>Dynamic rule</p><pre><code class="language-julia">@rule ~a::Number * ~b::Number =&gt; ~a*~b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Rules.jl#L186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.EqualityRule" href="#Metatheory.Rules.EqualityRule"><code>Metatheory.Rules.EqualityRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>EqualityRule</code> can is a symbolic substitution rule that  can be rewritten bidirectional. Therefore, it should only be used  with the EGraphs backend.</p><pre><code class="language-julia">@rule ~a * ~b == ~b * ~a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Rules.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.RewriteRule" href="#Metatheory.Rules.RewriteRule"><code>Metatheory.Rules.RewriteRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules defined as <code>left_hand --&gt; right_hand</code> are called <em>symbolic rewrite</em> rules. Application of a <em>rewrite</em> Rule is a replacement of the <code>left_hand</code> pattern with the <code>right_hand</code> substitution, with the correct instantiation of pattern variables. Function call symbols are not treated as pattern variables, all other identifiers are treated as pattern variables. Literals such as <code>5, :e, &quot;hello&quot;</code> are not treated as pattern variables.</p><pre><code class="language-julia">@rule ~a * ~b --&gt; ~b * ~a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Rules.jl#L38-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.UnequalRule" href="#Metatheory.Rules.UnequalRule"><code>Metatheory.Rules.UnequalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This type of <em>anti</em>-rules is used for checking contradictions in the EGraph backend. If two terms, corresponding to the left and right hand side of an <em>anti-rule</em> are found in an [<code>EGraph</code>], saturation is halted immediately. </p><pre><code class="language-julia">¬a ≠ a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Rules.jl#L142-L151">source</a></section></article><hr/><h2 id="Rules-2"><a class="docs-heading-anchor" href="#Rules-2">Rules</a><a class="docs-heading-anchor-permalink" href="#Rules-2" title="Permalink"></a></h2><hr/><h2 id="Rewriters"><a class="docs-heading-anchor" href="#Rewriters">Rewriters</a><a id="Rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rewriters" href="#Metatheory.Rewriters"><code>Metatheory.Rewriters</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A rewriter is any function which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression.</p><p>The <code>Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it retuns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. Note that if  <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk.  <code>threaded=true</code> will use multi threading for traversal. <code>thread_cutoff</code> is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>FixpointNoCycle</code> behaves like <a href="@ref"><code>Fixpoint</code></a> but instead it applies <code>rw</code> repeatedly only while it is returning new results.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul><hr/><p><strong>Imports</strong></p><ul><li><code>Base</code></li><li><code>Base.Threads</code></li><li><code>Core</code></li><li><code>TermInterface</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Rewriters.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rewriters.FixpointNoCycle" href="#Metatheory.Rewriters.FixpointNoCycle"><code>Metatheory.Rewriters.FixpointNoCycle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FixpointNoCycle(rw)</code></pre><p><code>FixpointNoCycle</code> behaves like <a href="@ref"><code>Fixpoint</code></a>, but returns a rewriter which applies <code>rw</code> repeatedly until  it produces a result that was already produced before, for example,  if the repeated application of <code>rw</code> produces results <code>a, b, c, d, b</code> in order,  <code>FixpointNoCycle</code> stops because <code>b</code> has been already produced. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/Rewriters.jl#L127-L135">source</a></section></article><hr/><h2 id="EGraphs"><a class="docs-heading-anchor" href="#EGraphs">EGraphs</a><a id="EGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#EGraphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.AbstractAnalysis" href="#Metatheory.EGraphs.AbstractAnalysis"><code>Metatheory.EGraphs.AbstractAnalysis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractAnalysis</code></pre><p>Abstract type representing an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> analysis, attaching values from a join semi-lattice domain to an EGraph</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.EGraph" href="#Metatheory.EGraphs.EGraph"><code>Metatheory.EGraphs.EGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct EGraph</code></pre><p>A concrete type representing an [<code>EGraph</code>]. See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> for implementation details.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>uf::IntDisjointSet</code></p><p>stores the equality relations over e-class ids</p></li><li><p><code>classes::Dict{Int64, EClass}</code></p><p>map from eclass id to eclasses</p></li><li><p><code>memo::Dict{AbstractENode, Int64}</code></p></li><li><p><code>dirty::Vector{Int64}</code></p><p>worklist for ammortized upwards merging</p></li><li><p><code>root::Int64</code></p></li><li><p><code>analyses::Set{Type{&lt;:AbstractAnalysis}}</code></p><p>A vector of analyses associated to the EGraph</p></li><li><p><code>default_termtype::Type</code></p></li><li><p><code>termtypes::Dict{Tuple{Any, Int64}, Type}</code></p></li><li><p><code>numclasses::Int64</code></p></li><li><p><code>numnodes::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.EGraph-Tuple{}" href="#Metatheory.EGraphs.EGraph-Tuple{}"><code>Metatheory.EGraphs.EGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EGraph(expr)</code></pre><p>Construct an EGraph from a starting symbolic expression <code>expr</code>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">EGraph() -&gt; EGraph
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">EGraph()</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L245"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:245</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.EqualityGoal" href="#Metatheory.EGraphs.EqualityGoal"><code>Metatheory.EGraphs.EqualityGoal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EqualityGoal &lt;: SaturationGoal</code></pre><p>This goal is reached when the <code>exprs</code> list of expressions are in the  same equivalence class.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>exprs::Vector{Any}</code></p></li><li><p><code>ids::Vector{Int64}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/saturation.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.ExtractionAnalysis" href="#Metatheory.EGraphs.ExtractionAnalysis"><code>Metatheory.EGraphs.ExtractionAnalysis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <a href="#Metatheory.EGraphs.AbstractAnalysis"><code>AbstractAnalysis</code></a> that computes the cost of expression nodes and chooses the node with the smallest cost for each E-Class. This abstract type is parametrised by a function F. This is useful for the analysis storage in <a href="@ref"><code>EClass</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.FunctionGoal" href="#Metatheory.EGraphs.FunctionGoal"><code>Metatheory.EGraphs.FunctionGoal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FunctionGoal &lt;: SaturationGoal</code></pre><p>Boolean valued function as an arbitrary saturation goal. User supplied function must take an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> as the only parameter.</p><hr/><p><strong>Fields</strong></p><ul><li><code>fun::Function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/saturation.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.SaturationParams" href="#Metatheory.EGraphs.SaturationParams"><code>Metatheory.EGraphs.SaturationParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SaturationParams</code></pre><p>Configurable Parameters for the equality saturation process.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>timeout::Int64</code></p><p>Default: 8</p></li><li><p><code>timelimit::Dates.Period</code></p><p>Default: Second(-1)</p></li><li><p><code>matchlimit::Int64</code></p><p>Default: 5000</p></li><li><p><code>eclasslimit::Int64</code></p><p>Default: 5000</p></li><li><p><code>enodelimit::Int64</code></p><p>Default: 15000</p></li><li><p><code>goal::Union{Nothing, SaturationGoal}</code></p><p>Default: nothing</p></li><li><p><code>stopwhen::Function</code></p><p>Default: ()-&gt;begin         #= /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:71 =#         false     end</p></li><li><p><code>scheduler::Type{&lt;:Metatheory.EGraphs.Schedulers.AbstractScheduler}</code></p><p>Default: BackoffScheduler</p></li><li><p><code>schedulerparams::Tuple</code></p><p>Default: ()</p></li><li><p><code>threaded::Bool</code></p><p>Default: false</p></li><li><p><code>timer::Bool</code></p><p>Default: true</p></li><li><p><code>printiter::Bool</code></p><p>Default: false</p></li><li><p><code>simterm::Function</code></p><p>Default: similarterm</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/saturation.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{EGraph, Int64, Int64}" href="#Base.merge!-Tuple{EGraph, Int64, Int64}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and two e-class ids, set the two e-classes as equal.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">merge!(g::EGraph, a::Int64, b::Int64) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">merge!(g, a, b)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L444"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:444</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.add!-Tuple{EGraph, AbstractENode}" href="#Metatheory.EGraphs.add!-Tuple{EGraph, AbstractENode}"><code>Metatheory.EGraphs.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inserts an e-node in an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">add!(g::EGraph, n::AbstractENode) -&gt; EClass
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">add!(g, n)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L354"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:354</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.addexpr!-Tuple{EGraph, EClass}" href="#Metatheory.EGraphs.addexpr!-Tuple{EGraph, EClass}"><code>Metatheory.EGraphs.addexpr!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recursively traverse an type satisfying the <code>TermInterface</code> and insert terms into an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. If <code>e</code> has no children (has an arity of 0) then directly insert the literal into the <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">addexpr!(g::EGraph, se::EClass; keepmeta) -&gt; Tuple{EClass, AbstractENode}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">addexpr!(g, se; keepmeta)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L404"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:404</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.analyze!-Tuple{EGraph, Type{&lt;:AbstractAnalysis}, Vector{Int64}}" href="#Metatheory.EGraphs.analyze!-Tuple{EGraph, Type{&lt;:AbstractAnalysis}, Vector{Int64}}"><code>Metatheory.EGraphs.analyze!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">analyze!(egraph, analysis, [ECLASS_IDS])</code></pre><p>Given an <a href="@ref">EGraph</a> and an <code>analysis</code> of type <code>&lt;:AbstractAnalysis</code>,  do an automated bottom up trasversal of the EGraph, associating a value from the  domain of <code>analysis</code> to each ENode in the egraph by the <a href="@ref">make</a> function.  Then, for each <a href="@ref">EClass</a>, compute the <a href="@ref">join</a> of the children ENodes analyses values. After <code>analyze!</code> is called, an analysis value will be associated to each EClass in the EGraph. One can inspect and retrieve analysis values by using <a href="@ref">hasdata</a> and <a href="@ref">getdata</a>.    Note that an <a href="@ref">EGraph</a> can only contain one analysis of type <code>an</code>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">analyze!(g::EGraph, an::Type{&lt;:AbstractAnalysis}, ids::Vector{Int64}) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">analyze!(g, an, ids)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L59"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:59</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.astsize-Tuple{ENodeTerm, EGraph, Type{&lt;:AbstractAnalysis}}" href="#Metatheory.EGraphs.astsize-Tuple{ENodeTerm, EGraph, Type{&lt;:AbstractAnalysis}}"><code>Metatheory.EGraphs.astsize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A basic cost function, where the computed cost is the size (number of children) of the current expression.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">astsize(n::ENodeTerm, g::EGraph, an::Type{&lt;:AbstractAnalysis}) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">astsize(n, g, an)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L98"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:98</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.astsize_inv-Tuple{ENodeTerm, EGraph, Type{&lt;:AbstractAnalysis}}" href="#Metatheory.EGraphs.astsize_inv-Tuple{ENodeTerm, EGraph, Type{&lt;:AbstractAnalysis}}"><code>Metatheory.EGraphs.astsize_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">astsize_inv(n::ENodeTerm, g::EGraph, an::Type{&lt;:AbstractAnalysis}) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">astsize_inv(n, g, an)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L115"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:115</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.eqsat_search!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Metatheory.EGraphs.Schedulers.AbstractScheduler, Any}" href="#Metatheory.EGraphs.eqsat_search!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Metatheory.EGraphs.Schedulers.AbstractScheduler, Any}"><code>Metatheory.EGraphs.eqsat_search!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns an iterator of <code>Match</code>es.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">eqsat_search!(egraph::EGraph, theory::Vector{&lt;:AbstractRule}, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, report; threaded) -&gt; Base.Iterators.Flatten{Vector{Vector{Metatheory.EGraphs.Match}}}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">eqsat_search!(egraph, theory, scheduler, report; threaded)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/saturation.jl#L156"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:156</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/saturation.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.eqsat_step!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Any, Metatheory.EGraphs.Schedulers.AbstractScheduler, Vector{Metatheory.EGraphs.Match}, SaturationParams, Any}" href="#Metatheory.EGraphs.eqsat_step!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Any, Metatheory.EGraphs.Schedulers.AbstractScheduler, Vector{Metatheory.EGraphs.Match}, SaturationParams, Any}"><code>Metatheory.EGraphs.eqsat_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Core algorithm of the library: the equality saturation step.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">eqsat_step!(g::EGraph, theory::Vector{&lt;:AbstractRule}, curr_iter, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, match_hist::Vector{Metatheory.EGraphs.Match}, params::SaturationParams, report) -&gt; Tuple{Any, EGraph}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">eqsat_step!(g, theory, curr_iter, scheduler, match_hist, params, report)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/saturation.jl#L291"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:291</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/saturation.jl#L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.extract!-Tuple{EGraph, Function}" href="#Metatheory.EGraphs.extract!-Tuple{EGraph, Function}"><code>Metatheory.EGraphs.extract!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a cost function, extract the expression with the smallest computed cost from an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">extract!(g::EGraph, costfun::Function; root, simterm, cse) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">extract!(g, costfun; root, simterm, cse)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L168"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:168</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.islazy-Tuple{Type{&lt;:AbstractAnalysis}}" href="#Metatheory.EGraphs.islazy-Tuple{Type{&lt;:AbstractAnalysis}}"><code>Metatheory.EGraphs.islazy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">islazy(an::Type{&lt;:AbstractAnalysis})</code></pre><p>Should return <code>true</code> if the EGraph Analysis <code>an</code> is lazy and false otherwise. A <em>lazy</em> EGraph Analysis is computed  only when <a href="@ref">analyze!</a> is called. <em>Non-lazy</em>  analyses are instead computed on-the-fly every time ENodes are added to the EGraph or EClasses are merged.  </p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">islazy(an::Type{&lt;:AbstractAnalysis}) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">islazy(an)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L10"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:10</code></a>.</p><pre><code class="language-julia">islazy(a)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L140"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:140</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.join-Tuple{Type{&lt;:AbstractAnalysis}, Any, Any}" href="#Metatheory.EGraphs.join-Tuple{Type{&lt;:AbstractAnalysis}, Any, Any}"><code>Metatheory.EGraphs.join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">join(an::Type{&lt;:AbstractAnalysis}, a, b)</code></pre><p>Joins two analyses values into a single one, used by <a href="@ref">analyze!</a> when two eclasses are being merged or the analysis is being constructed.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">join(analysis::Type{&lt;:AbstractAnalysis}, a, b) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">join(analysis, a, b)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L29"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:29</code></a>.</p><pre><code class="language-julia">join(a, from, to)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L138"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:138</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.make-Tuple{Type{&lt;:AbstractAnalysis}, Any, Any}" href="#Metatheory.EGraphs.make-Tuple{Type{&lt;:AbstractAnalysis}, Any, Any}"><code>Metatheory.EGraphs.make</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make(an::Type{&lt;:AbstractAnalysis}, g, n)</code></pre><p>Given an ENode <code>n</code>, <code>make</code> should return the corresponding analysis value. </p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">make(analysis::Type{&lt;:AbstractAnalysis}, g, n) -&gt; Tuple{AbstractENode, Any}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">make(analysis, g, n)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L37"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:37</code></a>.</p><pre><code class="language-julia">make(a, g, n)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L136"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:136</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.modify!-Tuple{Type{&lt;:AbstractAnalysis}, Any, Any}" href="#Metatheory.EGraphs.modify!-Tuple{Type{&lt;:AbstractAnalysis}, Any, Any}"><code>Metatheory.EGraphs.modify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">modify!(an::Type{&lt;:AbstractAnalysis}, g, id)</code></pre><p>The <code>modify!</code> function for EGraph Analysis can optionally modify the eclass <code>g[id]</code> after it has been analyzed, typically by adding an ENode. It should be <strong>idempotent</strong> if no other changes occur to the EClass.  (See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a>).</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">modify!(analysis::Type{&lt;:AbstractAnalysis}, g, id)
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">modify!(analysis, g, id)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/analysis.jl#L20"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:20</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/analysis.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.preprocess-Tuple{Expr}" href="#Metatheory.EGraphs.preprocess-Tuple{Expr}"><code>Metatheory.EGraphs.preprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extend this function on your types to do preliminary preprocessing of a symbolic term before adding it to  an EGraph. Most common preprocessing techniques are binarization of n-ary terms and metadata stripping.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">preprocess(e::Expr) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">preprocess(e)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L394"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:394</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.reachable-Tuple{EGraph, Int64}" href="#Metatheory.EGraphs.reachable-Tuple{EGraph, Int64}"><code>Metatheory.EGraphs.reachable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recursive function that traverses an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and returns a vector of all reachable e-classes from a given e-class id.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">reachable(g::EGraph, id::Int64) -&gt; Vector{Int64}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">reachable(g, id)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L590"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:590</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.rebuild!-Tuple{EGraph}" href="#Metatheory.EGraphs.rebuild!-Tuple{EGraph}"><code>Metatheory.EGraphs.rebuild!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function restores invariants and executes upwards merging in an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> for more details.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">rebuild!(g::EGraph) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">rebuild!(g)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/egraph.jl#L482"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:482</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/egraph.jl#L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.saturate!" href="#Metatheory.EGraphs.saturate!"><code>Metatheory.EGraphs.saturate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and a collection of rewrite rules, execute the equality saturation algorithm.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">saturate!(g::EGraph, theory::Vector{&lt;:AbstractRule}) -&gt; Metatheory.EGraphs.Report
saturate!(g::EGraph, theory::Vector{&lt;:AbstractRule}, params) -&gt; Metatheory.EGraphs.Report
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">saturate!(g, theory)
saturate!(g, theory, params)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/saturation.jl#L320"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:320</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/saturation.jl#L316">source</a></section></article><hr/><h2 id="EGraph-Schedulers"><a class="docs-heading-anchor" href="#EGraph-Schedulers">EGraph Schedulers</a><a id="EGraph-Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#EGraph-Schedulers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.AbstractScheduler" href="#Metatheory.EGraphs.Schedulers.AbstractScheduler"><code>Metatheory.EGraphs.Schedulers.AbstractScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractScheduler</code></pre><p>Represents a rule scheduler for the equality saturation process</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.BackoffScheduler" href="#Metatheory.EGraphs.Schedulers.BackoffScheduler"><code>Metatheory.EGraphs.Schedulers.BackoffScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct BackoffScheduler &lt;: Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.</p><p>This seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>data::IdDict{AbstractRule, Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}</code></p></li><li><p><code>G::EGraph</code></p></li><li><p><code>theory::Vector{&lt;:AbstractRule}</code></p></li><li><p><code>curr_iter::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.ScoredScheduler" href="#Metatheory.EGraphs.Schedulers.ScoredScheduler"><code>Metatheory.EGraphs.Schedulers.ScoredScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ScoredScheduler &lt;: Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.</p><p>This seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>data::IdDict{AbstractRule, Metatheory.EGraphs.Schedulers.ScoredSchedulerEntry}</code></p></li><li><p><code>G::EGraph</code></p></li><li><p><code>theory::Vector{&lt;:AbstractRule}</code></p></li><li><p><code>curr_iter::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.SimpleScheduler" href="#Metatheory.EGraphs.Schedulers.SimpleScheduler"><code>Metatheory.EGraphs.Schedulers.SimpleScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SimpleScheduler &lt;: Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A simple Rewrite Scheduler that applies every rule every time</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.cansaturate" href="#Metatheory.EGraphs.Schedulers.cansaturate"><code>Metatheory.EGraphs.Schedulers.cansaturate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Should return <code>true</code> if the e-graph can be said to be saturated</p><pre><code class="language-none">cansaturate(s::AbstractScheduler)</code></pre><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L63"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:63</code></a>.</p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L120"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:120</code></a>.</p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L230"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:230</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.cansearch" href="#Metatheory.EGraphs.Schedulers.cansearch"><code>Metatheory.EGraphs.Schedulers.cansearch</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Should return <code>false</code> if the rule <code>r</code> should be skipped</p><pre><code class="language-none">cansearch(s::AbstractScheduler, r::Rule)</code></pre><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">cansearch(s, r)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L64"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:64</code></a>.</p><pre><code class="language-julia">cansearch(s, r)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L100"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:100</code></a>.</p><pre><code class="language-julia">cansearch(s, r)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L172"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:172</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.inform!" href="#Metatheory.EGraphs.Schedulers.inform!"><code>Metatheory.EGraphs.Schedulers.inform!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function is called <strong>after</strong> pattern matching on the e-graph, informs the scheduler about the yielded matches. Returns <code>false</code> if the matches should not be yielded and ignored. </p><pre><code class="language-none">inform!(s::AbstractScheduler, r::AbstractRule, n_matches)</code></pre><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">inform!(s, r, n_matches)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L68"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:68</code></a>.</p><pre><code class="language-julia">inform!(s, rule, n_matches)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L123"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:123</code></a>.</p><pre><code class="language-julia">inform!(s, rule, n_matches)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/305a9d275b73e9cc4feda518a97b3b0fa8b23474//src/EGraphs/Schedulers.jl#L233"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:233</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/305a9d275b73e9cc4feda518a97b3b0fa8b23474/src/EGraphs/Schedulers.jl#L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interfacing with Metatheory.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 31 August 2022 08:34">Wednesday 31 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
