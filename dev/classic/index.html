<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Classical Rewriting Â· Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl</a></li><li><a class="tocitem" href="../theories/">Rules and Theories</a></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../analysis/">E-Graph Analysis</a></li><li><a class="tocitem" href="../extraction/">Extracting from an E-Graph</a></li><li><a class="tocitem" href="../schedulers/">Scheduling for E-Graph rewriting</a></li><li class="is-active"><a class="tocitem" href>Classical Rewriting</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#API-Docs"><span>API Docs</span></a></li></ul></li><li><a class="tocitem" href="../options/">Global Metatheory.jl Options</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Classical Rewriting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Classical Rewriting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/master/docs/src/classic.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Classical-Rewriting"><a class="docs-heading-anchor" href="#Classical-Rewriting">Classical Rewriting</a><a id="Classical-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-Rewriting" title="Permalink"></a></h1><p>There are some use cases where EGraphs and equality saturation are not required. The <strong>classical rewriting backend</strong> is suited for <strong>simple tasks</strong> when computing the whole equivalence class is overkill.</p><p>The classical rewriting backend can be accessed with the <a href="@ref"><code>rewrite</code></a> function, which uses a recursive fixed point iteration algorithm to rewrite a source expression. The expression can be traversed with a <strong>depth first</strong> (inner left expression) evaluation order, or with a <strong>breadth first</strong> (outer left expression) evaluation order. You can configure the evaluation order by passing the keyword argument <code>order=:inner</code> (default) or <code>order=:outer</code> to the <code>rewrite</code> function.</p><p><strong>Note</strong>: With the classical <a href="@ref"><code>rewrite</code></a> algorithm, rules are matched in order and applied deterministically: every iteration, only the first rule that matches is applied. This means that when using the <strong>classical rewriting backend</strong>, the <strong>ordering of rules in a theory matters!</strong>. If some rules produce a loop, which is common for regular algebraic rules such as <em>commutativity, distributivity and associativity</em>, the other following rules in the theory <em>will never be applied</em>.</p><p>The classical <code>rewrite</code> algorithm is suitable for:</p><ul><li>Simple Pattern Matching Tasks</li><li>Interpretation of Code (e.g. interpretation of an eDSL)</li><li>Non-Optimizing Compiler Steps and Transformations (e.g. Your eDSL â€“&gt; Julia)</li><li>Simple Deterministic Manipulation Tasks (e.g. cleaning expressions)</li></ul><p>For algebraic, mathematics oriented rewriting, please use the <a href="@ref"><code>EGraph</code></a> backend.</p><p>Rewriting loops are detected by keeping an history of hashes of the rewritten expression. When a loop is detected, rewriting stops immediately and returns the current expression.</p><p>Metatheory.jl is meant for composability: you can always compose and interleave rewriting steps that use the classical rewriting backend or the more advanced EGraph backend.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Let&#39;s simplify an expression in the <code>comm_monoid</code> theory by using the EGraph backend. After simplification, we may want to move all the <code>Ïƒ</code> symbols to the right of multiplications, we can do this simple task with a <em>classical rewriting</em> step, by using the <code>rewrite</code> function.</p><h5 id="Step-1:-Simplification-with-EGraphs"><a class="docs-heading-anchor" href="#Step-1:-Simplification-with-EGraphs">Step 1: Simplification with EGraphs</a><a id="Step-1:-Simplification-with-EGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Simplification-with-EGraphs" title="Permalink"></a></h5><pre><code class="language-julia">using Metatheory
using Metatheory.EGraphs
using Metatheory.Classic
using Metatheory.Library

@metatheory_init ()

comm_monoid = commutative_monoid(:(*), 1);
start_expr = :( (a * (1 * (2Ïƒ)) * (b * Ïƒ + (c * 1)) ) );
g = EGraph(start_expr);
saturate!(g, comm_monoid);
simplified = extract!(g, astsize)</code></pre><pre class="documenter-example-output">:((Ïƒ * b + c) * ((2Ïƒ) * a))</pre><h5 id="Step-2:-Moving-Ïƒ-to-the-right"><a class="docs-heading-anchor" href="#Step-2:-Moving-Ïƒ-to-the-right">Step 2: Moving Ïƒ to the right</a><a id="Step-2:-Moving-Ïƒ-to-the-right-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Moving-Ïƒ-to-the-right" title="Permalink"></a></h5><pre><code class="language-julia">moveright = @theory begin
	:Ïƒ * a 			=&gt; a*:Ïƒ
	(a * :Ïƒ) * b 	=&gt; (a * b) * :Ïƒ
	(:Ïƒ * a) * b 	=&gt; (a * b) * :Ïƒ
end;

simplified = rewrite(simplified, moveright)</code></pre><pre class="documenter-example-output">:((b * Ïƒ + c) * ((2a) * Ïƒ))</pre><h4 id="Assignment-to-variables-during-rewriting."><a class="docs-heading-anchor" href="#Assignment-to-variables-during-rewriting.">Assignment to variables during rewriting.</a><a id="Assignment-to-variables-during-rewriting.-1"></a><a class="docs-heading-anchor-permalink" href="#Assignment-to-variables-during-rewriting." title="Permalink"></a></h4><p>Using the <em>classical rewriting</em> backend, you may want to assign a value to an externally defined variable. Because of the nature of modules and the <a href="https://github.com/SciML/RuntimeGeneratedFunctions.jl"><code>RuntimeGeneratedFunction</code></a> compilation pipeline, it is not possible to assign values to variables in other modules. You can achieve such behaviour by using Julia <code>References</code> <a href="https://docs.julialang.org/en/v1/base/c/#Core.Ref">(docs)</a>, which behave similarly to pointers in other languages such as C or OCaml.</p><p><strong>Note</strong>: due to nondeterminism, it is unrecommended to assign values to <code>Ref</code>s when using the <strong>EGraph</strong> backend!</p><pre><code class="language-julia">safe_var = 0
ref_var = Ref{Real}(0)

reft = @theory begin
	:safe |&gt; (safe_var = Ï€)
	:ref |&gt; (ref_var[] = Ï€)
end

rewrite(:(safe), reft; order=:inner, m=@__MODULE__)
rewrite(:(ref), reft; order=:inner, m=@__MODULE__)

(safe_var, ref_var[])</code></pre><pre class="documenter-example-output">(0, Ï€)</pre><h3 id="A-Tiny-Imperative-Programming-Language-Interpreter"><a class="docs-heading-anchor" href="#A-Tiny-Imperative-Programming-Language-Interpreter">A Tiny Imperative Programming Language Interpreter</a><a id="A-Tiny-Imperative-Programming-Language-Interpreter-1"></a><a class="docs-heading-anchor-permalink" href="#A-Tiny-Imperative-Programming-Language-Interpreter" title="Permalink"></a></h3><p>Here is an example showing interpretation of a very tiny, turing complete subset of the Julia programming language. To achieve turing completeness in an imperative paradigm language, just integer+boolean arithmetic and <code>if</code> and <code>while</code> statements are needed. Since a recursive algorithm is sufficient for interpreting those expressions, this example <strong>does not</strong> use the e-graphs backend! Note how we are representing semantics for a different programming language by reusing the Julia AST data structure, and therefore efficiently reusing the Julia parser for our new toy language.</p><p>See this <a href="https://github.com/0x0f0f0f/Metatheory.jl/blob/master/test/test_while_interpreter.jl">test file</a>.</p><h2 id="API-Docs"><a class="docs-heading-anchor" href="#API-Docs">API Docs</a><a id="API-Docs-1"></a><a class="docs-heading-anchor-permalink" href="#API-Docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Classic" href="#Metatheory.Classic"><code>Metatheory.Classic</code></a> â€” <span class="docstring-category">Module</span></header><section><div><p>This module contains classical rewriting functions and utilities</p><hr/><p><strong>Imports</strong></p><ul><li><code>Base</code></li><li><code>Base.Meta</code></li><li><code>Core</code></li><li><code>MatchCore</code></li><li><code>Metatheory.Rules</code></li><li><code>Metatheory.Util</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/92551104458273d8d59dcd1abac23673c10b231a/src/Classic/Classic.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Classic.compile_theory-Tuple{Vector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Rule, Module}" href="#Metatheory.Classic.compile_theory-Tuple{Vector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Rule, Module}"><code>Metatheory.Classic.compile_theory</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/92551104458273d8d59dcd1abac23673c10b231a/src/Classic/matchcore_compiler.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Classic.rewrite-Tuple{Any, Union{Function, Vector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Rule}}" href="#Metatheory.Classic.rewrite-Tuple{Any, Union{Function, Vector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Rule}}"><code>Metatheory.Classic.rewrite</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>This function executes a classical rewriting algorithm on a Julia expression <code>ex</code>. Classical rewriting applies rule in order with a fixed point iteration:</p><p>This algorithm heavily relies on <a href="https://github.com/SciML/RuntimeGeneratedFunctions.jl">RuntimeGeneratedFunctions.jl</a> and the <a href="https://github.com/SciML/RuntimeGeneratedFunctions.jl">MatchCore</a> pattern matcher. <strong>NOTE</strong>: this does not involve the use of <a href="@ref"><code>EGraphs.EGraph</code></a> or equality saturation (<a href="@ref"><code>EGraphs.saturate!</code></a>). When using <code>rewrite</code>, be aware of infinite loops: Since rules are matched in order in every iteration, it is possible that commonly used symbolic rules such as commutativity or associativity of operators may cause this algorithm to have a cycling computation instantly. This algorithm detects cycling computation by keeping an history of hashes, and instantly returns when a cycle is detected.</p><p>This algorithm is suitable for simple, deterministic symbolic rewrites. For more advanced use cases, where it is needed to apply multiple rewrites at the same time, or it is known that rules are causing loops, please use <a href="@ref"><code>EGraphs.EGraph</code></a> and equality saturation (<a href="@ref"><code>EGraphs.saturate!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/92551104458273d8d59dcd1abac23673c10b231a/src/Classic/rewrite.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Classic.@compile_theory-Tuple{Any}" href="#Metatheory.Classic.@compile_theory-Tuple{Any}"><code>Metatheory.Classic.@compile_theory</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><p>Compile a theory at runtime to a closure that does the pattern matching job</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/92551104458273d8d59dcd1abac23673c10b231a/src/Classic/matchcore_compiler.jl#L119-L121">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../schedulers/">Â« Scheduling for E-Graph rewriting</a><a class="docs-footer-nextpage" href="../options/">Global Metatheory.jl Options Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 26 April 2021 11:34">Monday 26 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
