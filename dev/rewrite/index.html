<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Classical Term Rewriting · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl 2.0</a></li><li class="is-active"><a class="tocitem" href>Classical Term Rewriting</a><ul class="internal"><li><a class="tocitem" href="#Rule-based-rewriting"><span>Rule-based rewriting</span></a></li><li><a class="tocitem" href="#Composing-rewriters"><span>Composing rewriters</span></a></li></ul></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../visualizing/">Visualizing E-Graphs</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/calculational_logic/">Rewriting Calculational Logic</a></li><li><a class="tocitem" href="../tutorials/custom_types/">Interfacing with Metatheory.jl</a></li><li><a class="tocitem" href="../tutorials/fibonacci/">Benchmarking Fibonacci. E-Graphs memoize computation.</a></li><li><a class="tocitem" href="../tutorials/mu/">The MU Puzzle</a></li><li><a class="tocitem" href="../tutorials/propositional_logic/">Rewriting</a></li><li><a class="tocitem" href="../tutorials/while_interpreter/">Write a very tiny Turing Complete language in Julia.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Classical Term Rewriting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Classical Term Rewriting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/master/docs/src/rewrite.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Classical-Term-Rewriting"><a class="docs-heading-anchor" href="#Classical-Term-Rewriting">Classical Term Rewriting</a><a id="Classical-Term-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-Term-Rewriting" title="Permalink"></a></h1><h2 id="Rule-based-rewriting"><a class="docs-heading-anchor" href="#Rule-based-rewriting">Rule-based rewriting</a><a id="Rule-based-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-based-rewriting" title="Permalink"></a></h2><p>Rewrite rules match and transform an expression. A rule is written using either the <code>@rule</code> or <code>@theory</code> macros. It creates a callable <code>Rule</code> object.</p><h3 id="Basics-of-rule-based-term-rewriting-in-Metatheory.jl"><a class="docs-heading-anchor" href="#Basics-of-rule-based-term-rewriting-in-Metatheory.jl">Basics of rule-based term rewriting in Metatheory.jl</a><a id="Basics-of-rule-based-term-rewriting-in-Metatheory.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Basics-of-rule-based-term-rewriting-in-Metatheory.jl" title="Permalink"></a></h3><p><strong>NOTE:</strong> for a real world use case using mathematical constructs, please refer to <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils.jl</a>. SU provides optimized types for mathematical expressions, code generation and a polished set of rules for simplification.</p><p>Here is a simple symbolic rewrite rule, that uses formula for the double angle of the sine function:</p><pre><code class="language-julia">using Metatheory

r1 = @rule sin(2(~x)) --&gt; 2sin(~x)*cos(~x)

expr = :(sin(2z))
r1(expr)</code></pre><p>The <code>@rule</code> macro takes a pair of patterns  – the <em>matcher</em> and the <em>consequent</em> (<code>@rule matcher OPERATOR consequent</code>). If an expression matches the matcher pattern, it is rewritten to the consequent pattern. <code>@rule</code> returns a callable object that applies the rule to an expression. There are different kinds of rule in Metatheory.jl:</p><p><strong>Rule operators</strong>:</p><ul><li><code>LHS =&gt; RHS</code>: create a <code>DynamicRule</code>. The RHS is <em>evaluated</em> on rewrite.</li><li><code>LHS --&gt; RHS</code>: create a <code>RewriteRule</code>. The RHS is <strong>not</strong> evaluated but <em>symbolically substituted</em> on rewrite.</li><li><code>LHS == RHS</code>: create a <code>EqualityRule</code>. In e-graph rewriting, this rule behaves like <code>RewriteRule</code> but can go in both directions. Doesn&#39;t work in classical rewriting.</li><li><code>LHS ≠ RHS</code>: create a <code>UnequalRule</code>. Can only be used in e-graphs, and is used to eagerly stop the process of rewriting if LHS is found to be equal to RHS.</li></ul><p>You can use <strong>dynamic rules</strong>, defined with the <code>=&gt;</code> operator, to dynamically compute values in the right hand of expressions. This is the default behaviour of rules in <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils.jl</a> Dynamic rules, are similar to anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>=&gt;</code> rule is evaluated during rewriting: the values that produced a match are bound to the pattern variables.</p><p><code>~x</code> in the example is what is a <strong>slot variable</strong> (or <em>pattern</em> variable) named <code>x</code>. In a matcher pattern, slot variables are placeholders that match exactly one expression. When used on the consequent side, they stand in for the matched expression. If a slot variable appears twice in a matcher pattern, <strong>in classical rewriting</strong> all corresponding matches must be equal (as tested by <code>Base.isequal</code> function). Hence this rule says: if you see something added to itself, make it twice of that thing, and works as such.</p><p>If you try to apply this rule to an expression with triple angle, it will return <code>nothing</code> – this is the way a rule signifies failure to match.</p><pre><code class="language-julia">r1(:(sin(3z))) === nothing</code></pre><p>Slot variable (matcher) is not necessary a single variable</p><pre><code class="language-julia">r1(:(sin(2*(w-z))))</code></pre><p>but it must be a single expression</p><pre><code class="language-julia">r1(:(sin(2*(w+z)*(α+β)))) === nothing</code></pre><p>Rules are of course not limited to single slot variable</p><pre><code class="language-julia">r2 = @rule sin(~x + ~y) --&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y);

r2(:(sin(α+β)))</code></pre><p>If you want to match a variable number of subexpressions at once, you will need a <strong>segment variable</strong>. <code>~xs...</code> in the following example is a segment variable:</p><pre><code class="language-julia">@rule(+(~xs...) =&gt; xs)(:(x + y + z))</code></pre><p><code>~xs</code> is a vector of subexpressions matched. You can use it to construct something more useful:</p><pre><code class="language-julia">r3 = @rule *(~ys...)^~x =&gt; :((*)($(map(y-&gt; :($y^$x), ys)...)));

r3(:((w*w*α*β)^2))</code></pre><h3 id="Predicates-for-matching"><a class="docs-heading-anchor" href="#Predicates-for-matching">Predicates for matching</a><a id="Predicates-for-matching-1"></a><a class="docs-heading-anchor-permalink" href="#Predicates-for-matching" title="Permalink"></a></h3><p>Matcher pattern may contain slot variables with attached predicates, written as <code>~x::p</code> where <code>p</code> is either</p><ul><li>A function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if <code>p</code> returns true.</li><li>A Julia type. Will be considered a match if and only if the value matching against <code>x</code> has a type that is a subtype of <code>p</code> (<code>typeof(x) &lt;: p</code>)</li></ul><p>Similarly <code>~x::g...</code> is a way of attaching a predicate <code>g</code> to a segment variable. In the case of segment variables <code>g</code> gets a vector of 0 or more expressions and must return a boolean value. If the same slot or segment variable appears twice in the matcher pattern, then at most one of the occurrence should have a predicate.</p><p>For example,</p><pre><code class="language-julia">r = @rule +(~x, ~y::(ys-&gt;iseven(length(ys)))...) =&gt; &quot;odd terms&quot;;

@show r(:(a + b + c + d))
@show r(:(b + c + d))
@show r(:(b + c + b))
@show r(:(a + b))</code></pre><h3 id="Declaring-Slots"><a class="docs-heading-anchor" href="#Declaring-Slots">Declaring Slots</a><a id="Declaring-Slots-1"></a><a class="docs-heading-anchor-permalink" href="#Declaring-Slots" title="Permalink"></a></h3><p>Slot variables can be declared without the <code>~</code> using the <code>@slots</code> macro</p><pre><code class="language-julia">@slots x y @rule sin(x + y) =&gt; sin(x)*cos(y) + cos(x)*sin(y);</code></pre><p>This works for segments as well:</p><pre><code class="language-julia">@slots xs @rule(+(~xs...) =&gt; xs);</code></pre><p>The <code>@slots</code> macro is superfluous for the <code>@rule</code>, <code>@capture</code> and <code>@theory</code> macros. Slot variables may be declared directly as the first arguments to those macros:</p><pre><code class="language-julia">@rule x y sin(x + y) =&gt; sin(x)*cos(y) + cos(x)*sin(y);</code></pre><h3 id="Theories"><a class="docs-heading-anchor" href="#Theories">Theories</a><a id="Theories-1"></a><a class="docs-heading-anchor-permalink" href="#Theories" title="Permalink"></a></h3><p>In almost all use cases, it is practical to define many rules grouped together. A set of rewrite rules and equalities is called a <em>theory</em>, and can be defined with the <code>@theory</code> macro. This macro is just syntax sugar to define vectors of rules in a nice and readable way. </p><pre><code class="language-julia">t = @theory x y z begin 
    x * (y + z) --&gt; (x * y) + (x * z)
    x + y       ==  (y + x)
    #...
end;</code></pre><p>Is the same thing as writing</p><pre><code class="language-julia">v = [
    @rule x y z  x * (y + z) --&gt; (x * y) + (x * z)
    @rule x y x + y == (y + x)
    #...
];</code></pre><p>Theories are just collections and can be composed as regular Julia collections. The most useful way of composing theories is unioning them with the &#39;∪&#39; operator. You are not limited to composing theories, you can manipulate and create them at both runtime and compile time as regular vectors.</p><pre><code class="language-julia">using Metatheory
using Metatheory.Library

comm_monoid = @commutative_monoid (*) 1
comm_group = @theory a b c begin
    a + 0 --&gt; a
    a + b --&gt; b + a
    a + inv(a) --&gt; 0 # inverse
    a + (b + c) --&gt; (a + b) + c
end
distrib = @theory a b c begin
    a * (b + c) =&gt; (a * b) + (a * c)
end
t = comm_monoid ∪ comm_group ∪ distrib</code></pre><h2 id="Composing-rewriters"><a class="docs-heading-anchor" href="#Composing-rewriters">Composing rewriters</a><a id="Composing-rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Composing-rewriters" title="Permalink"></a></h2><p>Rules may be <em>chained together</em> into more sophisticated rewriters to avoid manual application of the rules. A rewriter is any callable object which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression. The Rules we created above are rewriters.</p><p>The <code>Metatheory.Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it returns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order   (<em>from top to bottom and from left to right</em>) traversal of a given expression and applies   the rewriter <code>rw</code>. <code>threaded=true</code> will use multi threading for traversal.  Note that if <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk. If you are  applying multiple rules, then <code>Chain</code> already has the appropriate passthrough behavior.  If you only want to apply one rule, then consider using <code>PassThrough</code>.  <code>thread_cutoff</code>   is the minimum number of nodes in a subtree which should be walked in a threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order   (<em>from left to right and from bottom to top</em>) traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>FixpointNoCycle</code> behaves like <code>Fixpoint</code> but instead it applies <code>rw</code> repeatedly only while it is returning new results.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul><h3 id="Chaining-rewriters"><a class="docs-heading-anchor" href="#Chaining-rewriters">Chaining rewriters</a><a id="Chaining-rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Chaining-rewriters" title="Permalink"></a></h3><p>Several rules may be chained to give chain of rules. Chain is an array of rules which are subsequently applied to the expression. Important feature of <code>Chain</code> is that it returns the expression instead of <code>nothing</code> if it doesn&#39;t change the expression It is important to notice, that chain is ordered, so if rules are in different order it wouldn&#39;t work the same as in earlier example</p><p>One way to circumvent the problem of order of applying rules in chain is to use <code>RestartedChain</code>, it restarts the chain after each successful application of a rule, so after a rule is hit it (re)starts again and it can apply all the other rules to the resulting expression. You can also use <code>Fixpoint</code> to apply the rules until there are no changes.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Metatheory.jl 2.0</a><a class="docs-footer-nextpage" href="../egraphs/">EGraphs and Equality Saturation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 January 2024 21:02">Tuesday 9 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
