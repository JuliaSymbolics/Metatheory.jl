<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Write a very tiny Turing Complete language in Julia. · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Metatheory.jl 2.0</a></li><li><a class="tocitem" href="../../rewrite/">Classical Term Rewriting</a></li><li><a class="tocitem" href="../../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../../api/">API Documentation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../custom_types/">Interfacing with Metatheory.jl</a></li><li><a class="tocitem" href="../mu/">The MU Puzzle</a></li><li class="is-active"><a class="tocitem" href>Write a very tiny Turing Complete language in Julia.</a><ul class="internal"><li><a class="tocitem" href="#Memory"><span>Memory</span></a></li><li><a class="tocitem" href="#Arithmetics"><span>Arithmetics</span></a></li><li><a class="tocitem" href="#Evaluation-strategy"><span>Evaluation strategy</span></a></li><li><a class="tocitem" href="#Boolean-Logic"><span>Boolean Logic</span></a></li><li><a class="tocitem" href="#Conditionals:-If-then-else"><span>Conditionals: If-then-else</span></a></li><li><a class="tocitem" href="#Writing-memory"><span>Writing memory</span></a></li><li><a class="tocitem" href="#While-loops-and-sequential-computation."><span>While loops and sequential computation.</span></a></li><li><a class="tocitem" href="#Completing-the-language."><span>Completing the language.</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Write a very tiny Turing Complete language in Julia.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Write a very tiny Turing Complete language in Julia.</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/master/test/tutorials/while_interpreter.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Write-a-very-tiny-Turing-Complete-language-in-Julia."><a class="docs-heading-anchor" href="#Write-a-very-tiny-Turing-Complete-language-in-Julia.">Write a very tiny Turing Complete language in Julia.</a><a id="Write-a-very-tiny-Turing-Complete-language-in-Julia.-1"></a><a class="docs-heading-anchor-permalink" href="#Write-a-very-tiny-Turing-Complete-language-in-Julia." title="Permalink"></a></h1><p>WHILE is a very tiny Turing Complete Programming Language defined by denotational semantics. Semantics come from the excellent <a href="http://pages.di.unipi.it/degano/ECC-uno.pdf">course notes</a> in <em>&quot;Elements of computability and complexity&quot;</em>  by prof. <a href="http://pages.di.unipi.it/degano/">Pierpaolo Degano</a>.</p><p>It is a toy C-like language used to explain the core concepts of computability and Turing-completeness. The name WHILE, comes from the fact that the most complicated construct in the language is a WHILE loop. The language supports:</p><ul><li>A variable-value memory that can be pre-defined for program input.</li><li>Integer arithmetics.</li><li>Boolean logic.</li><li>Conditional if-then-else statement called <code>cond</code>.</li><li>Running a command after another with <code>seq(c1,c2)</code>.</li><li>Repeatedly applying a command <code>c</code> while a condition <code>g</code> holds with <code>loop(g,c)</code>.</li></ul><p>This is enough to be Turing-complete!</p><p>We are going to implement this tiny imperative language with classical rewriting rules in <a href="https://github.com/JuliaSymbolics/Metatheory.jl/">Metatheory.jl</a>. WHILE is implemented in around 55 readable lines of code, and reaches around 80 lines with tests.</p><p>The goal of this tutorial is to show an implementation of a programming language interpreter that is very, very very close to the simple theory used to describe it in a textbook. Each denotational semantics rule in the course notes is a Metatheory.jl rewrite rule, with a few extras and minor naming changes. The idea, is that Julia is a really valid didactical programming language!</p><p>Let&#39;s load the Metatheory and Test packages.</p><pre><code class="language-julia">using Test, Metatheory</code></pre><h2 id="Memory"><a class="docs-heading-anchor" href="#Memory">Memory</a><a id="Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Memory" title="Permalink"></a></h2><p>The first thing that our programming language needs, is a model of the <em>computer memory</em>, that is going to hold the state of the programs. We define the type of WHILE&#39;s memory as a map from variables (Julia <code>Symbol</code>s) to actual values. We want to keep things simple so in our toy programming language we are just going to use boolean or integer values. Surprisingly, we can still achieve turing completeness without having to introduce strings or any other complex data type. We are going to use the letter <code>σ</code> (sigma) to denote an actual value of type <code>Mem</code>, in simple words the state of a program in a given moment. For example, if a <code>σ::Mem</code> holds the value <code>σ[:a] = 2</code>, this means that at that given moment, in our program the variable <code>a</code> holds the value 2.</p><pre><code class="language-julia">Mem = Dict{Symbol,Union{Bool,Int}}</code></pre><pre class="documenter-example-output">Dict{Symbol, Union{Bool, Int64}}</pre><p>We are now ready to define our first rewrite rule. In WHILE, un-evaluated expressions are represented by a tuple of <code>(program, state)</code>. This simple rule tells us that, if at a given memory state <code>σ</code> we want to know the value of a variable <code>v</code>, we can simply read it from the memory and return the value.</p><pre><code class="language-julia">read_mem = @theory v σ begin
  (v::Symbol, σ::Mem) =&gt; σ[v]
end</code></pre><pre class="documenter-example-output">1-element Vector{DynamicRule}:
 (~(v::Symbol), ~(σ::Mem)) =&gt; σ[v]</pre><p>Let&#39;s test this behavior. We first create a <code>Mem</code>, holding the variable <code>x</code> with value 2.</p><pre><code class="language-julia">σ₁ = Mem(:x =&gt; 2)</code></pre><pre class="documenter-example-output">Dict{Symbol, Union{Bool, Int64}} with 1 entry:
  :x =&gt; 2</pre><p>Then, we define a program. Julia helps us avoid unneeded complications. Generally, to create an interpreted programming language, one would have to design a syntax for it, and then engineer components such as a lexer or a <a href="https://en.wikipedia.org/wiki/Parsing">parser</a> in order to turn the input string into a manipulable, structured program. The Julia developers were really smart. We can directly re-use the whole Julia syntax, because Julia allows us to treat programs as values. You can try this by prefixing any expression you type in the REPL inside of <code>:( ... )</code> or <code>quote ... end</code>. If you type this in the Julia REPL:</p><pre><code class="language-julia">2 + 2</code></pre><pre class="documenter-example-output">4</pre><p>You get the obvious result out, but if you wrap it in <code>quote</code> or <code>:(...)</code>, you can see that the program will not be executed, but instead stored as an <code>Expr</code>.</p><pre><code class="language-julia">some_expr = :(2 + 2)
dump(some_expr)</code></pre><pre class="documenter-example-output">Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 2
    3: Int64 2</pre><p>We can use the <code>$</code> unary operator to interpolate and insert values inside of quoted code.</p><pre><code class="language-julia">:(2 + $(1 + 1))</code></pre><pre class="documenter-example-output">:(2 + 2)</pre><p>These code-manipulation utilities can be very useful, because we can completely skip the burden of having to write a new syntax for our educational programming language, and just re-use Julia&#39;s syntax. It hints us that Julia is very powerful, because you can define new semantics and customize the language&#39;s behaviour without having to leave the comfort of the Julia terminal. This is also how julia <code>@macros</code> work. The practice of manipulating programs in the language itself is called <strong>Metaprogramming</strong>, and you can read more about metaprogramming in Julia <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">in the official docs</a>.</p><p>Let&#39;s test that our first, simple rule is working.</p><pre><code class="language-julia">program = :(x, $σ₁)
@test rewrite(program, read_mem) == 2</code></pre><pre class="documenter-example-output">Test Passed</pre><h2 id="Arithmetics"><a class="docs-heading-anchor" href="#Arithmetics">Arithmetics</a><a id="Arithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetics" title="Permalink"></a></h2><p>How can our programming language be turing complete if we do not include basic arithmetics? If we have an integer and a memory state, we can just keep the integer The following rules are the first cases of recursion. Given two expressions <code>a,b</code>, to know what&#39;s <code>a + b</code> in state <code>σ</code>, we need to know first what <code>a</code> and <code>b</code> are in state σ The last dynamic rules let us directly evaluate arithmetic operations.</p><pre><code class="language-julia">arithm_rules = @theory a b n σ begin
  (n::Int, σ::Mem) --&gt; n
  (a + b, σ::Mem) --&gt; (a, σ) + (b, σ)
  (a * b, σ::Mem) --&gt; (a, σ) * (b, σ)
  (a - b, σ::Mem) --&gt; (a, σ) - (b, σ)
  (a::Int + b::Int) =&gt; a + b
  (a::Int * b::Int) =&gt; a * b
  (a::Int - b::Int) =&gt; a - b
end</code></pre><pre class="documenter-example-output">7-element Vector{AbstractRule}:
 (~(n::Int), ~(σ::Mem)) --&gt; ~n
 (~a + ~b, ~(σ::Mem)) --&gt; (~a, ~σ) + (~b, ~σ)
 (~a * ~b, ~(σ::Mem)) --&gt; (~a, ~σ) * (~b, ~σ)
 (~a - ~b, ~(σ::Mem)) --&gt; (~a, ~σ) - (~b, ~σ)
 ~(a::Int) + ~(b::Int) =&gt; a + b
 ~(a::Int) * ~(b::Int) =&gt; a * b
 ~(a::Int) - ~(b::Int) =&gt; a - b</pre><h2 id="Evaluation-strategy"><a class="docs-heading-anchor" href="#Evaluation-strategy">Evaluation strategy</a><a id="Evaluation-strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-strategy" title="Permalink"></a></h2><p>We now have some nice denotational semantic rules for arithmetics, but in what order should we apply them? Metatheory.jl provides a flexible rewriter combinator library. You can read more in the <a href="../../api/#Rewriters">Rewriters</a> module docs.</p><p>Given a set of rules, we can define  a rewriter strategy by functionally composing rewriters. First, we want to use <code>Chain</code> to combine together the many rules in the theory, and to try to apply them one-by-one on our expressions.</p><p>But should we first evaluate the outermost operations in the expression, or the innermost? Intuitively, if we have the program <code>(1 + 2) - 3</code>, it can hint us that we do want to first evaluate the innermost expressions. To do so, we then pass the result to the <a href="tutorials/@ref">Postwalk</a> rewriter, which recursively walks the input expression tree, and applies the rewriter first on the inner expressions, and then, on the outer, rewritten expression. (Hence the name <code>Post</code>-walk. Can you guess what <a href="tutorials/@ref">Prewalk</a> does?).</p><p>The last component of our strategy is the <a href="tutorials/@ref">Fixpoint</a> combinator. This combinator repeatedly applies the rewriter on the input expression, and it does stop looping only when the output expression is the unchanged input expression.</p><pre><code class="language-julia">using Metatheory.Rewriters
strategy = (Fixpoint ∘ Postwalk ∘ Chain)</code></pre><pre class="documenter-example-output">Metatheory.Rewriters.Fixpoint ∘ Metatheory.Rewriters.Postwalk ∘ Metatheory.Rewriters.Chain</pre><p>In Metatheory.jl, rewrite theories are just vectors of <a href="tutorials/@ref">Rules</a>. It means we can compose them by concatenating the vectors, or elegantly using the built-in set operations provided by the Julia language.</p><pre><code class="language-julia">arithm_lang = read_mem ∪ arithm_rules</code></pre><pre class="documenter-example-output">8-element Vector{AbstractRule}:
 (~(v::Symbol), ~(σ::Mem)) =&gt; σ[v]
 (~(n::Int), ~(σ::Mem)) --&gt; ~n
 (~a + ~b, ~(σ::Mem)) --&gt; (~a, ~σ) + (~b, ~σ)
 (~a * ~b, ~(σ::Mem)) --&gt; (~a, ~σ) * (~b, ~σ)
 (~a - ~b, ~(σ::Mem)) --&gt; (~a, ~σ) - (~b, ~σ)
 ~(a::Int) + ~(b::Int) =&gt; a + b
 ~(a::Int) * ~(b::Int) =&gt; a * b
 ~(a::Int) - ~(b::Int) =&gt; a - b</pre><p>We can define a convenience function that takes an expression, a memory state and calls our strategy.</p><pre><code class="language-julia">eval_arithm(ex, mem) = strategy(arithm_lang)(:($ex, $mem))</code></pre><pre class="documenter-example-output">eval_arithm (generic function with 1 method)</pre><p>Does it work?</p><pre><code class="language-julia">@test eval_arithm(:(2 + 3), Mem()) == 5</code></pre><pre class="documenter-example-output">Test Passed</pre><p>Yay! Let&#39;s say that before the program started, the computer memory already held a variable <code>x</code> with value 2.</p><pre><code class="language-julia">@test eval_arithm(:(2 + x), Mem(:x =&gt; 2)) == 4</code></pre><pre class="documenter-example-output">Test Passed</pre><h2 id="Boolean-Logic"><a class="docs-heading-anchor" href="#Boolean-Logic">Boolean Logic</a><a id="Boolean-Logic-1"></a><a class="docs-heading-anchor-permalink" href="#Boolean-Logic" title="Permalink"></a></h2><p>To be Turing-complete, our tiny WHILE language requires boolean logic support. There&#39;s nothing special or different from other programming languages. These rules define boolean operations to work just as you would expect, and in the same way we defined arithmetic rules for integers.</p><p>We need to bridge together the world of integer arithmetics and boolean logic to achieve something useful. The last two rules in the theory.</p><pre><code class="language-julia">bool_rules = @theory a b σ begin
  (a::Bool || b::Bool) =&gt; (a || b)
  (a::Bool &amp;&amp; b::Bool) =&gt; (a &amp;&amp; b)
  !a::Bool =&gt; !a
  (a::Bool, σ::Mem) =&gt; a
  (!b, σ::Mem) =&gt; !eval_bool(b, σ)
  (a || b, σ::Mem) --&gt; (a, σ) || (b, σ)
  (a &amp;&amp; b, σ::Mem) --&gt; (a, σ) &amp;&amp; (b, σ)
  (a &lt; b, σ::Mem) =&gt; (eval_arithm(a, σ) &lt; eval_arithm(b, σ)) # This rule bridges together ints and bools
  (a::Int &lt; b::Int) =&gt; (a &lt; b)
end

eval_bool(ex, mem) = strategy(bool_rules)(:($ex, $mem))</code></pre><pre class="documenter-example-output">eval_bool (generic function with 1 method)</pre><p>Let&#39;s run a few tests.</p><pre><code class="language-julia">@test all(
  [
    eval_bool(:(false || false), Mem()) == false
    eval_bool(:((false || false) || !(false || false)), Mem(:x =&gt; 2)) == true
    eval_bool(:((2 &lt; 3) &amp;&amp; (3 &lt; 4)), Mem(:x =&gt; 2)) == true
    eval_bool(:((2 &lt; x) || !(3 &lt; 4)), Mem(:x =&gt; 2)) == false
    eval_bool(:((2 &lt; x) || !(3 &lt; 4)), Mem(:x =&gt; 4)) == true
  ],
)</code></pre><pre class="documenter-example-output">Test Passed</pre><h2 id="Conditionals:-If-then-else"><a class="docs-heading-anchor" href="#Conditionals:-If-then-else">Conditionals: If-then-else</a><a id="Conditionals:-If-then-else-1"></a><a class="docs-heading-anchor-permalink" href="#Conditionals:-If-then-else" title="Permalink"></a></h2><p>Conditional expressions in our language take the form of <code>cond(guard, thenbranch)</code> or <code>cond(guard, branch, elsebranch)</code> It means that our program at this point will:</p><ol><li>Evaluate the <code>guard</code> expressions</li><li>If <code>guard</code> evaluates to <code>true</code>, then evaluate <code>thenbranch</code></li><li>If <code>guard</code> evaluates to <code>false</code>, then evaluate <code>elsebranch</code></li></ol><p>The first rule here is simple. If there&#39;s no <code>elsebranch</code> in the <code>cond</code> statement, we add an empty one with the <code>skip</code> command. Otherwise, we piggyback on the existing Julia if-then-else ternary operator. To do so, we need to evaluate the boolean expression in the guard by using the <code>eval_bool</code> function we defined above.</p><pre><code class="language-julia">function cond end
if_rules = @theory guard t f σ begin
  (cond(guard, t), σ::Mem) --&gt; (cond(guard, t, :skip), σ)
  (cond(guard, t, f), σ::Mem) =&gt; (eval_bool(guard, σ) ? :($t, $σ) : :($f, $σ))
end

eval_if(ex, mem::Mem) = strategy(read_mem ∪ arithm_rules ∪ if_rules)(:($ex, $mem))</code></pre><pre class="documenter-example-output">eval_if (generic function with 1 method)</pre><p>And here is our working conditional</p><pre><code class="language-julia">@testset &quot;If Semantics&quot; begin
  @test 2 == eval_if(:(cond(true, x, 0)), Mem(:x =&gt; 2))
  @test 0 == eval_if(:(cond(false, x, 0)), Mem(:x =&gt; 2))
  @test 2 == eval_if(:(cond(!(false), x, 0)), Mem(:x =&gt; 2))
  @test 0 == eval_if(:(cond(!(2 &lt; x), x, 0)), Mem(:x =&gt; 3))
end</code></pre><pre class="documenter-example-output">Test.DefaultTestSet(&quot;If Semantics&quot;, Any[], 4, false, false, true, 1.685549599237733e9, 1.685549599885748e9)</pre><h2 id="Writing-memory"><a class="docs-heading-anchor" href="#Writing-memory">Writing memory</a><a id="Writing-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-memory" title="Permalink"></a></h2><p>Our language then needs a mechanism to write in memory. We define the behavior of the <code>store</code> construct, which behaves like the <code>=</code> assignment operator in other programming languages. <code>store(a, 5)</code> will store the value 5 in the <code>a</code> variable inside the program&#39;s memory.</p><pre><code class="language-julia">function store end
write_mem = @theory sym val σ begin
  (store(sym::Symbol, val), σ) =&gt; (σ[sym] = eval_if(val, σ);
  σ)
end</code></pre><pre class="documenter-example-output">1-element Vector{DynamicRule}:
 (store(~(sym::Symbol), ~val), ~σ) =&gt; begin
        σ[sym] = eval_if(val, σ)
        σ
    end</pre><h2 id="While-loops-and-sequential-computation."><a class="docs-heading-anchor" href="#While-loops-and-sequential-computation.">While loops and sequential computation.</a><a id="While-loops-and-sequential-computation.-1"></a><a class="docs-heading-anchor-permalink" href="#While-loops-and-sequential-computation." title="Permalink"></a></h2><pre><code class="language-julia">function seq end
function loop end
while_rules = @theory guard a b σ begin
  (:skip, σ::Mem) --&gt; σ
  ((:skip; b), σ::Mem) --&gt; (b, σ)
  (seq(a, b), σ::Mem) --&gt; (b, merge((a, σ), σ))
  merge(a::Mem, σ::Mem) =&gt; merge(σ, a)
  merge(a::Union{Bool,Int}, σ::Mem) --&gt; σ
  (loop(guard, a), σ::Mem) --&gt; (cond(guard, seq(a, loop(guard, a)), :skip), σ)
end</code></pre><pre class="documenter-example-output">6-element Vector{AbstractRule}:
 (skip, ~(σ::Mem)) --&gt; ~σ
 (begin
        skip
        ~b
    end, ~(σ::Mem)) --&gt; (~b, ~σ)
 (seq(~a, ~b), ~(σ::Mem)) --&gt; (~b, merge((~a, ~σ), ~σ))
 merge(~(a::Mem), ~(σ::Mem)) =&gt; merge(σ, a)
 merge(~(a::Union{Bool, Int}), ~(σ::Mem)) --&gt; ~σ
 (loop(~guard, ~a), ~(σ::Mem)) --&gt; (cond(~guard, seq(~a, loop(~guard, ~a)), skip), ~σ)</pre><h2 id="Completing-the-language."><a class="docs-heading-anchor" href="#Completing-the-language.">Completing the language.</a><a id="Completing-the-language.-1"></a><a class="docs-heading-anchor-permalink" href="#Completing-the-language." title="Permalink"></a></h2><pre><code class="language-julia">while_language = write_mem ∪ read_mem ∪ arithm_rules ∪ if_rules ∪ while_rules;

using Metatheory.Syntax: rmlines
eval_while(ex, mem) = strategy(while_language)(:($(rmlines(ex)), $mem))</code></pre><pre class="documenter-example-output">eval_while (generic function with 1 method)</pre><p>Final steps</p><pre><code class="language-julia">@testset &quot;While Semantics&quot; begin
  @test Mem(:x =&gt; 3) == eval_while(:((store(x, 3))), Mem(:x =&gt; 2))
  @test Mem(:x =&gt; 5) == eval_while(:(seq(store(x, 4), store(x, x + 1))), Mem(:x =&gt; 3))
  @test Mem(:x =&gt; 4) == eval_while(:(cond(x &lt; 10, store(x, x + 1))), Mem(:x =&gt; 3))
  @test 10 == eval_while(:(seq(loop(x &lt; 10, store(x, x + 1)), x)), Mem(:x =&gt; 3))
  @test 50 == eval_while(:(seq(loop(x &lt; y, seq(store(x, x + 1), store(y, y - 1))), x)), Mem(:x =&gt; 0, :y =&gt; 100))
end</code></pre><pre class="documenter-example-output">Test.DefaultTestSet(&quot;While Semantics&quot;, Any[], 5, false, false, true, 1.685549602304272e9, 1.685549603713064e9)</pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mu/">« The MU Puzzle</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 31 May 2023 16:13">Wednesday 31 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
