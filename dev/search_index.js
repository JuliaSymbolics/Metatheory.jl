var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Syntax","page":"API Documentation","title":"Syntax","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.Syntax]","category":"page"},{"location":"api/#Metatheory.Syntax.rewrite_rhs-Tuple{Expr}","page":"API Documentation","title":"Metatheory.Syntax.rewrite_rhs","text":"rewrite_rhs(expr::Expr)\n\nRewrite the expr by dealing with :where if necessary. The :where is rewritten from, for example, ~x where f(~x) to f(~x) ? ~x : nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Syntax.rmlines-Tuple{Expr}","page":"API Documentation","title":"Metatheory.Syntax.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Syntax.@rule-Tuple","page":"API Documentation","title":"Metatheory.Syntax.@rule","text":"@rule [SLOTS...] LHS operator RHS\n\nCreates an AbstractRule object. A rule object is callable, and takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns nothing otherwise. The rule language is described below.\n\nLHS can be any possibly nested function call expression where any of the arugments can optionally be a Slot (~x) or a Segment (~x...) (described below).\n\nSLOTS is an optional list of symbols to be interpeted as slots or segments directly (without using ~).  To declare slots for several rules at once, see the @slots macro.\n\nIf an expression matches LHS entirely, then it is rewritten to the pattern in the RHS , whose local scope includes the slot matches as variables. Segment (~x) and slot variables (~~x) on the RHS will substitute the result of the matches found for these variables in the LHS.\n\nRule operators:\n\nLHS => RHS: create a DynamicRule. The RHS is evaluated on rewrite.\nLHS --> RHS: create a RewriteRule. The RHS is not evaluated but symbolically substituted on rewrite.\nLHS == RHS: create a EqualityRule. In e-graph rewriting, this rule behaves like RewriteRule but can go in both directions. Doesn't work in classical rewriting\nLHS ≠ RHS: create a UnequalRule. Can only be used in e-graphs, and is used to eagerly stop the process of rewriting if LHS is found to be equal to RHS.\n\nSlot:\n\nA Slot variable is written as ~x and matches a single expression. x is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by isequal).\n\nExample:\n\nSimple rule to turn any sin into cos:\n\njulia> r = @rule sin(~x) --> cos(~x)\nsin(~x) --> cos(~x)\n\njulia> r(:(sin(1+a)))\n:(cos((1 + a)))\n\nA rule with 2 segment variables\n\njulia> r = @rule sin(~x + ~y) --> sin(~x)*cos(~y) + cos(~x)*sin(~y)\nsin(~x + ~y) --> sin(~x) * cos(~y) + cos(~x) * sin(~y)\n\njulia> r(:(sin(a + b)))\n:(cos(a)*sin(b) + sin(a)*cos(b))\n\nA rule that matches two of the same expressions:\n\njulia> r = @rule sin(~x)^2 + cos(~x)^2 --> 1\nsin(~x) ^ 2 + cos(~x) ^ 2 --> 1\n\njulia> r(:(sin(2a)^2 + cos(2a)^2))\n1\n\njulia> r(:(sin(2a)^2 + cos(a)^2))\n# nothing\n\nA rule without ~\n\njulia> r = @slots x y z @rule x(y + z) --> x*y + x*z\nx(y + z) --> x*y + x*z\n\nSegment: A Segment variable matches zero or more expressions in the function call. Segments may be written by splatting slot variables (~x...).\n\nExample:\n\njulia> r = @rule f(~xs...) --> g(~xs...);\njulia> r(:(f(1, 2, 3)))\n:(g(1,2,3))\n\nPredicates:\n\nThere are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both ~x and ~~x by using the ~x::f or ~~x::f. Here f can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.\n\nThe predicate should return true if the current match is acceptable, and false otherwise.\n\njulia> two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) < 10^-9\ntwo_πs (generic function with 1 method)\n\njulia> two_πs(x) = false\ntwo_πs (generic function with 2 methods)\n\njulia> r = @rule sin(~~x + ~y::two_πs + ~~z) => :(sin($(Expr(:call, :+, ~~x..., ~~z...))))\nsin(~(~x) + ~(y::two_πs) + ~(~z)) --> sin(+(~(~x)..., ~(~z)...))\n\njulia> r(:(sin(a+$(3π))))\n\njulia> r(:(sin(a+$(6π))))\n:(sin(+a))\n\njulia> r(sin(a+6π+c))\n:(sin(a + c))\n\nPredicate function gets an array of values if attached to a segment variable (~x...).\n\nFor the predicate over the whole rule, use @rule <LHS> => <RHS> where <predicate>:\n\njulia> predicate(x) = x === a;\n\njulia> r = @rule ~x => ~x where f(~x);\n\njulia> r(a)\na\n\njulia> r(b) === nothing\ntrue\n\nNote that this is syntactic sugar and that it is the same as @rule ~x => f(~x) ? ~x : nothing.\n\nCompatibility: Segment variables may still be written as (~~x), and slot (~x) and segment (~x... or ~~x) syntaxes on the RHS will still substitute the result of the matches. See also: @capture, @slots\n\n\n\n\n\n","category":"macro"},{"location":"api/#Metatheory.Syntax.@slots-Tuple","page":"API Documentation","title":"Metatheory.Syntax.@slots","text":"@slots [SLOTS...] ex\n\nDeclare SLOTS as slot variables for all @rule or @capture invocations in the expression ex. Example:\n\njulia> @slots x y z a b c Chain([\n    (@rule x^2 + 2x*y + y^2 => (x + y)^2),\n    (@rule x^a * y^b => (x*y)^a * y^(b-a)),\n    (@rule +(x...) => sum(x)),\n])\n\nSee also: @rule, @capture\n\n\n\n\n\n","category":"macro"},{"location":"api/#Metatheory.Syntax.@theory-Tuple","page":"API Documentation","title":"Metatheory.Syntax.@theory","text":"@theory [SLOTS...] begin (LHS operator RHS)... end\n\nSyntax sugar to define a vector of rules in a nice and readable way. Can use @slots or have the slots  as the first arguments:\n\njulia> t = @theory x y z begin \n    x * (y + z) --> (x * y) + (x * z)\n    x + y       ==  (y + x)\n    #...\nend;\n\nIs the same thing as writing\n\njulia> v = [\n    @rule x y z  x * (y + z) --> (x * y) + (x * z)\n    @rule x y x + y == (y + x)\n    #...\n];\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/#Patterns","page":"API Documentation","title":"Patterns","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.Patterns]","category":"page"},{"location":"api/#Metatheory.Patterns.AbstractPat","page":"API Documentation","title":"Metatheory.Patterns.AbstractPat","text":"Abstract type representing a pattern used in all the various pattern matching backends. \n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Patterns.PatSegment","page":"API Documentation","title":"Metatheory.Patterns.PatSegment","text":"If you want to match a variable number of subexpressions at once, you will need a segment pattern.  A segment pattern represents a vector of subexpressions matched.  You can attach a predicate g to a segment variable. In the case of segment variables g gets a vector of 0 or more  expressions and must return a boolean value. \n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Patterns.PatTerm","page":"API Documentation","title":"Metatheory.Patterns.PatTerm","text":"Term patterns will match on terms of the same arity and with the same  function symbol operation and expression head exprhead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Patterns.PatVar","page":"API Documentation","title":"Metatheory.Patterns.PatVar","text":"PatVar{P}(name, debrujin_index, predicate::P)\n\nPattern variables will first match on one subterm and instantiate the substitution to that subterm.\n\nMatcher pattern may contain pattern variables with attached predicates, where predicate is a function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if f returns true.\n\npredicate can also be a Type{<:t}, this predicate is called a  type assertion. Type assertions on a PatVar, will match if and only if  the type of the matched term for the pattern variable is a subtype of T. \n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Patterns.isground-Tuple{AbstractPat}","page":"API Documentation","title":"Metatheory.Patterns.isground","text":"A ground pattern contains no pattern variables and  only literal values to match.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Patterns.patvars-Tuple{PatVar, Any}","page":"API Documentation","title":"Metatheory.Patterns.patvars","text":"Collects pattern variables appearing in a pattern into a vector of symbols\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/#Rules","page":"API Documentation","title":"Rules","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.Rules]","category":"page"},{"location":"api/#Metatheory.Rules.DynamicRule","page":"API Documentation","title":"Metatheory.Rules.DynamicRule","text":"Rules defined as left_hand => right_hand are called dynamic rules. Dynamic rules behave like anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic => rule is evaluated during rewriting: matched values are bound to pattern variables as in a regular function call. This allows for dynamic computation of right hand sides.\n\nDynamic rule\n\n@rule ~a::Number * ~b::Number => ~a*~b\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Rules.EqualityRule","page":"API Documentation","title":"Metatheory.Rules.EqualityRule","text":"An EqualityRule can is a symbolic substitution rule that  can be rewritten bidirectional. Therefore, it should only be used  with the EGraphs backend.\n\n@rule ~a * ~b == ~b * ~a\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Rules.RewriteRule","page":"API Documentation","title":"Metatheory.Rules.RewriteRule","text":"Rules defined as left_hand --> right_hand are called symbolic rewrite rules. Application of a rewrite Rule is a replacement of the left_hand pattern with the right_hand substitution, with the correct instantiation of pattern variables. Function call symbols are not treated as pattern variables, all other identifiers are treated as pattern variables. Literals such as 5, :e, \"hello\" are not treated as pattern variables.\n\n@rule ~a * ~b --> ~b * ~a\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Rules.UnequalRule","page":"API Documentation","title":"Metatheory.Rules.UnequalRule","text":"This type of anti-rules is used for checking contradictions in the EGraph backend. If two terms, corresponding to the left and right hand side of an anti-rule are found in an [EGraph], saturation is halted immediately. \n\n¬a ≠ a\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/#Rules-2","page":"API Documentation","title":"Rules","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.Rules]","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/#Rewriters","page":"API Documentation","title":"Rewriters","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.Rewriters]","category":"page"},{"location":"api/#Metatheory.Rewriters","page":"API Documentation","title":"Metatheory.Rewriters","text":"A rewriter is any function which takes an expression and returns an expression or nothing. If nothing is returned that means there was no changes applicable to the input expression.\n\nThe Rewriters module contains some types which create and transform rewriters.\n\nEmpty() is a rewriter which always returns nothing\nChain(itr) chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns nothing this is treated as a no-change.\nRestartedChain(itr) like Chain(itr) but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.\nIfElse(cond, rw1, rw2) runs the cond function on the input, applies rw1 if cond  returns true, rw2 if it retuns false\nIf(cond, rw) is the same as IfElse(cond, rw, Empty())\nPrewalk(rw; threaded=false, thread_cutoff=100) returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter rw. Note that if  rw returns nothing when a match is not found, then Prewalk(rw) will  also return nothing unless a match is found at every level of the walk.  threaded=true will use multi threading for traversal. thread_cutoff is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.\nPostwalk(rw; threaded=false, thread_cutoff=100) similarly does post-order traversal.\nFixpoint(rw) returns a rewriter which applies rw repeatedly until there are no changes to be made.\nFixpointNoCycle behaves like Fixpoint but instead it applies rw repeatedly only while it is returning new results.\nPassThrough(rw) returns a rewriter which if rw(x) returns nothing will instead  return x otherwise will return rw(x).\n\n\n\nImports\n\nBase\nBase.Threads\nCore\nTermInterface\n\n\n\n\n\n","category":"module"},{"location":"api/#Metatheory.Rewriters.FixpointNoCycle","page":"API Documentation","title":"Metatheory.Rewriters.FixpointNoCycle","text":"FixpointNoCycle(rw)\n\nFixpointNoCycle behaves like Fixpoint, but returns a rewriter which applies rw repeatedly until  it produces a result that was already produced before, for example,  if the repeated application of rw produces results a, b, c, d, b in order,  FixpointNoCycle stops because b has been already produced. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/#EGraphs","page":"API Documentation","title":"EGraphs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs]","category":"page"},{"location":"api/#Metatheory.EGraphs.AbstractAnalysis","page":"API Documentation","title":"Metatheory.EGraphs.AbstractAnalysis","text":"abstract type AbstractAnalysis\n\nAbstract type representing an EGraph analysis, attaching values from a join semi-lattice domain to an EGraph\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.EGraph","page":"API Documentation","title":"Metatheory.EGraphs.EGraph","text":"mutable struct EGraph\n\nA concrete type representing an [EGraph]. See the egg paper for implementation details.\n\n\n\nFields\n\nuf::IntDisjointSet\nstores the equality relations over e-class ids\nclasses::Dict{Int64, EClass}\nmap from eclass id to eclasses\nmemo::Dict{AbstractENode, Int64}\ndirty::Vector{Int64}\nworklist for ammortized upwards merging\nroot::Int64\nanalyses::Set{Type{var\"#s10\"} where var\"#s10\"<:AbstractAnalysis}\nA vector of analyses associated to the EGraph\ndefault_termtype::Type\ntermtypes::Dict{Tuple{Any, Int64}, Type}\nnumclasses::Int64\nnumnodes::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.EGraph-Tuple{}","page":"API Documentation","title":"Metatheory.EGraphs.EGraph","text":"EGraph(expr)\n\nConstruct an EGraph from a starting symbolic expression expr.\n\n\n\nSignatures\n\nEGraph() -> EGraph\n\n\n\n\nMethods\n\nEGraph()\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:242.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.EqualityGoal","page":"API Documentation","title":"Metatheory.EGraphs.EqualityGoal","text":"struct EqualityGoal <: SaturationGoal\n\nThis goal is reached when the exprs list of expressions are in the  same equivalence class.\n\n\n\nFields\n\nexprs::Vector{Any}\nids::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.ExtractionAnalysis","page":"API Documentation","title":"Metatheory.EGraphs.ExtractionAnalysis","text":"An AbstractAnalysis that computes the cost of expression nodes and chooses the node with the smallest cost for each E-Class. This abstract type is parametrised by a function F. This is useful for the analysis storage in EClass\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.FunctionGoal","page":"API Documentation","title":"Metatheory.EGraphs.FunctionGoal","text":"struct FunctionGoal <: SaturationGoal\n\nBoolean valued function as an arbitrary saturation goal. User supplied function must take an EGraph as the only parameter.\n\n\n\nFields\n\nfun::Function\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.SaturationParams","page":"API Documentation","title":"Metatheory.EGraphs.SaturationParams","text":"mutable struct SaturationParams\n\nConfigurable Parameters for the equality saturation process.\n\n\n\nFields\n\ntimeout::Int64\nDefault: 8\nmatchlimit::Int64\nDefault: 5000\neclasslimit::Int64\nDefault: 5000\nenodelimit::Int64\nDefault: 15000\ngoal::Union{Nothing, SaturationGoal}\nDefault: nothing\nstopwhen::Function\nDefault: ()->begin         #= /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:70 =#         false     end\nscheduler::Type{var\"#s226\"} where var\"#s226\"<:Metatheory.EGraphs.Schedulers.AbstractScheduler\nDefault: BackoffScheduler\nschedulerparams::Tuple\nDefault: ()\nthreaded::Bool\nDefault: false\ntimer::Bool\nDefault: true\nprintiter::Bool\nDefault: false\nsimterm::Function\nDefault: similarterm\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.merge!-Tuple{EGraph, Int64, Int64}","page":"API Documentation","title":"Base.merge!","text":"Given an EGraph and two e-class ids, set the two e-classes as equal.\n\n\n\nSignatures\n\nmerge!(g::EGraph, a::Int64, b::Int64) -> Int64\n\n\n\n\nMethods\n\nmerge!(g, a, b)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:441.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.add!-Tuple{EGraph, AbstractENode}","page":"API Documentation","title":"Metatheory.EGraphs.add!","text":"Inserts an e-node in an EGraph\n\n\n\nSignatures\n\nadd!(g::EGraph, n::AbstractENode) -> EClass\n\n\n\n\nMethods\n\nadd!(g, n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:351.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.addexpr!-Tuple{EGraph, EClass}","page":"API Documentation","title":"Metatheory.EGraphs.addexpr!","text":"Recursively traverse an type satisfying the TermInterface and insert terms into an EGraph. If e has no children (has an arity of 0) then directly insert the literal into the EGraph.\n\n\n\nSignatures\n\naddexpr!(g::EGraph, se::EClass; keepmeta) -> Tuple{EClass, AbstractENode}\n\n\n\n\nMethods\n\naddexpr!(g, se; keepmeta)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:401.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.analyze!-Tuple{EGraph, Type{var\"#s223\"} where var\"#s223\"<:AbstractAnalysis, Vector{Int64}}","page":"API Documentation","title":"Metatheory.EGraphs.analyze!","text":"analyze!(egraph, analysis, [ECLASS_IDS])\n\nGiven an EGraph and an analysis of type <:AbstractAnalysis,  do an automated bottom up trasversal of the EGraph, associating a value from the  domain of analysis to each ENode in the egraph by the make function.  Then, for each EClass, compute the join of the children ENodes analyses values. After analyze! is called, an analysis value will be associated to each EClass in the EGraph. One can inspect and retrieve analysis values by using hasdata and getdata.    Note that an EGraph can only contain one analysis of type an.\n\n\n\nSignatures\n\nanalyze!(g::EGraph, an::Type{var\"#s223\"} where var\"#s223\"<:AbstractAnalysis, ids::Vector{Int64}) -> Bool\n\n\n\n\nMethods\n\nanalyze!(g, an, ids)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:59.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.astsize-Tuple{ENodeTerm, EGraph, Type{var\"#s224\"} where var\"#s224\"<:AbstractAnalysis}","page":"API Documentation","title":"Metatheory.EGraphs.astsize","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression.\n\n\n\nSignatures\n\nastsize(n::ENodeTerm, g::EGraph, an::Type{var\"#s224\"} where var\"#s224\"<:AbstractAnalysis) -> Any\n\n\n\n\nMethods\n\nastsize(n, g, an)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:98.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.astsize_inv-Tuple{ENodeTerm, EGraph, Type{var\"#s224\"} where var\"#s224\"<:AbstractAnalysis}","page":"API Documentation","title":"Metatheory.EGraphs.astsize_inv","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression\n\n\n\nSignatures\n\nastsize_inv(n::ENodeTerm, g::EGraph, an::Type{var\"#s224\"} where var\"#s224\"<:AbstractAnalysis) -> Any\n\n\n\n\nMethods\n\nastsize_inv(n, g, an)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:115.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.eqsat_search!-Tuple{EGraph, Vector{var\"#s225\"} where var\"#s225\"<:AbstractRule, Metatheory.EGraphs.Schedulers.AbstractScheduler, Any}","page":"API Documentation","title":"Metatheory.EGraphs.eqsat_search!","text":"Returns an iterator of Matches.\n\n\n\nSignatures\n\neqsat_search!(egraph::EGraph, theory::Vector{var\"#s225\"} where var\"#s225\"<:AbstractRule, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, report; threaded) -> Base.Iterators.Flatten{Vector{Vector{Metatheory.EGraphs.Match}}}\n\n\n\n\nMethods\n\neqsat_search!(egraph, theory, scheduler, report; threaded)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:155.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.eqsat_step!-Tuple{EGraph, Vector{var\"#s253\"} where var\"#s253\"<:AbstractRule, Any, Metatheory.EGraphs.Schedulers.AbstractScheduler, Vector{Metatheory.EGraphs.Match}, SaturationParams, Any}","page":"API Documentation","title":"Metatheory.EGraphs.eqsat_step!","text":"Core algorithm of the library: the equality saturation step.\n\n\n\nSignatures\n\neqsat_step!(g::EGraph, theory::Vector{var\"#s253\"} where var\"#s253\"<:AbstractRule, curr_iter, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, match_hist::Vector{Metatheory.EGraphs.Match}, params::SaturationParams, report) -> Tuple{Any, EGraph}\n\n\n\n\nMethods\n\neqsat_step!(g, theory, curr_iter, scheduler, match_hist, params, report)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:290.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.extract!-Tuple{EGraph, Function}","page":"API Documentation","title":"Metatheory.EGraphs.extract!","text":"Given a cost function, extract the expression with the smallest computed cost from an EGraph\n\n\n\nSignatures\n\nextract!(g::EGraph, costfun::Function; root, simterm) -> Any\n\n\n\n\nMethods\n\nextract!(g, costfun; root, simterm)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:187.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.extract!-Tuple{EGraph, Type{ExtractionAnalysis{F}} where F}","page":"API Documentation","title":"Metatheory.EGraphs.extract!","text":"Given an ExtractionAnalysis, extract the expression with the smallest computed cost from an EGraph\n\n\n\nSignatures\n\nextract!(g::EGraph, a::Type{ExtractionAnalysis{F}} where F; root, simterm) -> Any\n\n\n\n\nMethods\n\nextract!(g, a; root, simterm)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:174.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.islazy-Tuple{Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis}","page":"API Documentation","title":"Metatheory.EGraphs.islazy","text":"islazy(an::Type{<:AbstractAnalysis})\n\nShould return true if the EGraph Analysis an is lazy and false otherwise. A lazy EGraph Analysis is computed  only when analyze! is called. Non-lazy  analyses are instead computed on-the-fly every time ENodes are added to the EGraph or EClasses are merged.  \n\n\n\nSignatures\n\nislazy(an::Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis) -> Bool\n\n\n\n\nMethods\n\nislazy(an)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:10.\n\nislazy(a)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:140.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.join-Tuple{Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis, Any, Any}","page":"API Documentation","title":"Metatheory.EGraphs.join","text":"join(an::Type{<:AbstractAnalysis}, a, b)\n\nJoins two analyses values into a single one, used by analyze! when two eclasses are being merged or the analysis is being constructed.\n\n\n\nSignatures\n\njoin(analysis::Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis, a, b) -> Any\n\n\n\n\nMethods\n\njoin(analysis, a, b)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:29.\n\njoin(a, from, to)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:138.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.make-Tuple{Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis, Any, Any}","page":"API Documentation","title":"Metatheory.EGraphs.make","text":"make(an::Type{<:AbstractAnalysis}, g, n)\n\nGiven an ENode n, make should return the corresponding analysis value. \n\n\n\nSignatures\n\nmake(analysis::Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis, g, n) -> Tuple{AbstractENode, Any}\n\n\n\n\nMethods\n\nmake(analysis, g, n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:37.\n\nmake(a, g, n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:136.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.modify!-Tuple{Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis, Any, Any}","page":"API Documentation","title":"Metatheory.EGraphs.modify!","text":"modify!(an::Type{<:AbstractAnalysis}, g, id)\n\nThe modify! function for EGraph Analysis can optionally modify the eclass g[id] after it has been analyzed, typically by adding an ENode. It should be idempotent if no other changes occur to the EClass.  (See the egg paper).\n\n\n\nSignatures\n\nmodify!(analysis::Type{var\"#s225\"} where var\"#s225\"<:AbstractAnalysis, g, id)\n\n\n\n\nMethods\n\nmodify!(analysis, g, id)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.preprocess-Tuple{Expr}","page":"API Documentation","title":"Metatheory.EGraphs.preprocess","text":"Extend this function on your types to do preliminary preprocessing of a symbolic term before adding it to  an EGraph. Most common preprocessing techniques are binarization of n-ary terms and metadata stripping.\n\n\n\nSignatures\n\npreprocess(e::Expr) -> Any\n\n\n\n\nMethods\n\npreprocess(e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:391.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.reachable-Tuple{EGraph, Int64}","page":"API Documentation","title":"Metatheory.EGraphs.reachable","text":"Recursive function that traverses an EGraph and returns a vector of all reachable e-classes from a given e-class id.\n\n\n\nSignatures\n\nreachable(g::EGraph, id::Int64) -> Vector{Int64}\n\n\n\n\nMethods\n\nreachable(g, id)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:587.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.rebuild!-Tuple{EGraph}","page":"API Documentation","title":"Metatheory.EGraphs.rebuild!","text":"This function restores invariants and executes upwards merging in an EGraph. See the egg paper for more details.\n\n\n\nSignatures\n\nrebuild!(g::EGraph) -> Bool\n\n\n\n\nMethods\n\nrebuild!(g)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:479.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.saturate!","page":"API Documentation","title":"Metatheory.EGraphs.saturate!","text":"Given an EGraph and a collection of rewrite rules, execute the equality saturation algorithm.\n\n\n\nSignatures\n\nsaturate!(g::EGraph, theory::Vector{var\"#s251\"} where var\"#s251\"<:AbstractRule) -> Metatheory.EGraphs.Report\nsaturate!(g::EGraph, theory::Vector{var\"#s250\"} where var\"#s250\"<:AbstractRule, params) -> Metatheory.EGraphs.Report\n\n\n\n\nMethods\n\nsaturate!(g, theory)\nsaturate!(g, theory, params)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:319.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"","category":"page"},{"location":"api/#EGraph-Schedulers","page":"API Documentation","title":"EGraph Schedulers","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs.Schedulers]","category":"page"},{"location":"api/#Metatheory.EGraphs.Schedulers.AbstractScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.AbstractScheduler","text":"abstract type AbstractScheduler\n\nRepresents a rule scheduler for the equality saturation process\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.BackoffScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.BackoffScheduler","text":"mutable struct BackoffScheduler <: Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\nFields\n\ndata::IdDict{AbstractRule, Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}\nG::EGraph\ntheory::Vector{var\"#s226\"} where var\"#s226\"<:AbstractRule\ncurr_iter::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.ScoredScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.ScoredScheduler","text":"mutable struct ScoredScheduler <: Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\nFields\n\ndata::IdDict{AbstractRule, Metatheory.EGraphs.Schedulers.ScoredSchedulerEntry}\nG::EGraph\ntheory::Vector{var\"#s226\"} where var\"#s226\"<:AbstractRule\ncurr_iter::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.SimpleScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.SimpleScheduler","text":"struct SimpleScheduler <: Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA simple Rewrite Scheduler that applies every rule every time\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.cansaturate","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.cansaturate","text":"Should return true if the e-graph can be said to be saturated\n\ncansaturate(s::AbstractScheduler)\n\n\n\nSignatures\n\n\n\nMethods\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:63.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:120.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:230.\n\n\n\n\n\n","category":"function"},{"location":"api/#Metatheory.EGraphs.Schedulers.cansearch","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.cansearch","text":"Should return false if the rule r should be skipped\n\ncansearch(s::AbstractScheduler, r::Rule)\n\n\n\nSignatures\n\n\n\nMethods\n\ncansearch(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:64.\n\ncansearch(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:100.\n\ncansearch(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:172.\n\n\n\n\n\n","category":"function"},{"location":"api/#Metatheory.EGraphs.Schedulers.inform!","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.inform!","text":"This function is called after pattern matching on the e-graph, informs the scheduler about the yielded matches. Returns false if the matches should not be yielded and ignored. \n\ninform!(s::AbstractScheduler, r::AbstractRule, n_matches)\n\n\n\nSignatures\n\n\n\nMethods\n\ninform!(s, r, n_matches)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:68.\n\ninform!(s, rule, n_matches)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:123.\n\ninform!(s, rule, n_matches)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:233.\n\n\n\n\n\n","category":"function"},{"location":"rewrite/#Classical-Term-Rewriting","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"","category":"section"},{"location":"rewrite/#Rule-based-rewriting","page":"Classical Term Rewriting","title":"Rule-based rewriting","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Rewrite rules match and transform an expression. A rule is written using either the @rule or @theory macros. It creates a callable Rule object.","category":"page"},{"location":"rewrite/#Basics-of-rule-based-term-rewriting-in-Metatheory.jl","page":"Classical Term Rewriting","title":"Basics of rule-based term rewriting in Metatheory.jl","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"NOTE: for a real world use case using mathematical constructs, please refer to SymbolicUtils.jl. SU provides optimized types for mathematical expressions, code generation and a polished set of rules for simplification.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Here is a simple symbolic rewrite rule, that uses formula for the double angle of the sine function:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"using Metatheory\n\nr1 = @rule sin(2(~x)) --> 2sin(~x)*cos(~x)\n\nexpr = :(sin(2z))\nr1(expr)","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"The @rule macro takes a pair of patterns  – the matcher and the consequent (@rule matcher OPERATOR consequent). If an expression matches the matcher pattern, it is rewritten to the consequent pattern. @rule returns a callable object that applies the rule to an expression. There are different kinds of rule in Metatheory.jl:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Rule operators:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"LHS => RHS: create a DynamicRule. The RHS is evaluated on rewrite.\nLHS --> RHS: create a RewriteRule. The RHS is not evaluated but symbolically substituted on rewrite.\nLHS == RHS: create a EqualityRule. In e-graph rewriting, this rule behaves like RewriteRule but can go in both directions. Doesn't work in classical rewriting.\nLHS ≠ RHS: create a UnequalRule. Can only be used in e-graphs, and is used to eagerly stop the process of rewriting if LHS is found to be equal to RHS.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"You can use dynamic rules, defined with the => operator, to dynamically compute values in the right hand of expressions. This is the default behaviour of rules in SymbolicUtils.jl Dynamic rules, are similar to anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic => rule is evaluated during rewriting: the values that produced a match are bound to the pattern variables.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"~x in the example is what is a slot variable (or pattern variable) named x. In a matcher pattern, slot variables are placeholders that match exactly one expression. When used on the consequent side, they stand in for the matched expression. If a slot variable appears twice in a matcher pattern, in classical rewriting all corresponding matches must be equal (as tested by Base.isequal function). Hence this rule says: if you see something added to itself, make it twice of that thing, and works as such.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"If you try to apply this rule to an expression with triple angle, it will return nothing – this is the way a rule signifies failure to match.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"r1(:(sin(3z))) === nothing","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Slot variable (matcher) is not necessary a single variable","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"r1(:(sin(2*(w-z))))","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"but it must be a single expression","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"r1(:(sin(2*(w+z)*(α+β)))) === nothing","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Rules are of course not limited to single slot variable","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"r2 = @rule sin(~x + ~y) --> sin(~x)*cos(~y) + cos(~x)*sin(~y);\n\nr2(:(sin(α+β)))","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"If you want to match a variable number of subexpressions at once, you will need a segment variable. ~xs... in the following example is a segment variable:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"@rule(+(~xs...) => xs)(:(x + y + z))","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"~xs is a vector of subexpressions matched. You can use it to construct something more useful:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"r3 = @rule *(~ys...)^~x => :((*)($(map(y-> :($y^$x), ys)...)));\n\nr3(:((w*w*α*β)^2))","category":"page"},{"location":"rewrite/#Predicates-for-matching","page":"Classical Term Rewriting","title":"Predicates for matching","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Matcher pattern may contain slot variables with attached predicates, written as ~x::p where p is either","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"A function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if p returns true.\nA Julia type. Will be considered a match if and only if the value matching against x has a type that is a subtype of p (typeof(x) <: p)","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Similarly ~x::g... is a way of attaching a predicate g to a segment variable. In the case of segment variables g gets a vector of 0 or more expressions and must return a boolean value. If the same slot or segment variable appears twice in the matcher pattern, then at most one of the occurance should have a predicate.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"For example,","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"r = @rule +(~x, ~y::(ys->iseven(length(ys)))...) => \"odd terms\";\n\n@show r(:(a + b + c + d))\n@show r(:(b + c + d))\n@show r(:(b + c + b))\n@show r(:(a + b))","category":"page"},{"location":"rewrite/#Declaring-Slots","page":"Classical Term Rewriting","title":"Declaring Slots","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Slot variables can be declared without the ~ using the @slots macro","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"@slots x y @rule sin(x + y) => sin(x)*cos(y) + cos(x)*sin(y);","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"This works for segments as well:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"@slots xs @rule(+(~xs...) => xs);","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"The @slots macro is superfluous for the @rule, @capture and @theory macros. Slot variables may be declared directly as the first arguments to those macros:","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"@rule x y sin(x + y) => sin(x)*cos(y) + cos(x)*sin(y);","category":"page"},{"location":"rewrite/#Theories","page":"Classical Term Rewriting","title":"Theories","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"In almost all use cases, it is practical to define many rules grouped together. A set of rewrite rules and equalities is called a theory, and can be defined with the @theory macro. This macro is just syntax sugar to define vectors of rules in a nice and readable way. ","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"t = @theory x y z begin \n    x * (y + z) --> (x * y) + (x * z)\n    x + y       ==  (y + x)\n    #...\nend;","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Is the same thing as writing","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"v = [\n    @rule x y z  x * (y + z) --> (x * y) + (x * z)\n    @rule x y x + y == (y + x)\n    #...\n];","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Theories are just collections and can be composed as regular Julia collections. The most useful way of composing theories is unioning them with the '∪' operator. You are not limited to composing theories, you can manipulate and create them at both runtime and compile time as regular vectors.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"using Metatheory\nusing Metatheory.Library\n\ncomm_monoid = @commutative_monoid (*) 1\ncomm_group = @theory a b c begin\n    a + 0 --> a\n    a + b --> b + a\n    a + inv(a) --> 0 # inverse\n    a + (b + c) --> (a + b) + c\nend\ndistrib = @theory a b c begin\n    a * (b + c) => (a * b) + (a * c)\nend\nt = comm_monoid ∪ comm_group ∪ distrib","category":"page"},{"location":"rewrite/#Composing-rewriters","page":"Classical Term Rewriting","title":"Composing rewriters","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Rules may be chained together into more sophisticated rewirters to avoid manual application of the rules. A rewriter is any callable object which takes an expression and returns an expression or nothing. If nothing is returned that means there was no changes applicable to the input expression. The Rules we created above are rewriters.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"The Metatheory.Rewriters module contains some types which create and transform rewriters.","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Empty() is a rewriter which always returns nothing\nChain(itr) chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns nothing this is treated as a no-change.\nRestartedChain(itr) like Chain(itr) but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.\nIfElse(cond, rw1, rw2) runs the cond function on the input, applies rw1 if cond  returns true, rw2 if it retuns false\nIf(cond, rw) is the same as IfElse(cond, rw, Empty())\nPrewalk(rw; threaded=false, thread_cutoff=100) returns a rewriter which does a pre-order   (from top to bottom and from left to right) traversal of a given expression and applies   the rewriter rw. threaded=true will use multi threading for traversal.  Note that if rw returns nothing when a match is not found, then Prewalk(rw) will  also return nothing unless a match is found at every level of the walk. If you are  applying multiple rules, then Chain already has the appropriate passthrough behavior.  If you only want to apply one rule, then consider using PassThrough.  thread_cutoff   is the minimum number of nodes in a subtree which should be walked in a threaded spawn.\nPostwalk(rw; threaded=false, thread_cutoff=100) similarly does post-order   (from left to right and from bottom to top) traversal.\nFixpoint(rw) returns a rewriter which applies rw repeatedly until there are no changes to be made.\nFixpointNoCycle behaves like Fixpoint but instead it applies rw repeatedly only while it is returning new results.\nPassThrough(rw) returns a rewriter which if rw(x) returns nothing will instead  return x otherwise will return rw(x).","category":"page"},{"location":"rewrite/#Chaining-rewriters","page":"Classical Term Rewriting","title":"Chaining rewriters","text":"","category":"section"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"Several rules may be chained to give chain of rules. Chain is an array of rules which are subsequently applied to the expression. Important feature of Chain is that it returns the expression instead of nothing if it doesn't change the expression It is important to notice, that chain is ordered, so if rules are in different order it wouldn't work the same as in earlier example","category":"page"},{"location":"rewrite/","page":"Classical Term Rewriting","title":"Classical Term Rewriting","text":"One way to circumvent the problem of order of applying rules in chain is to use RestartedChain, it restarts the chain after each successful application of a rule, so after a rule is hit it (re)starts again and it can apply all the other rules to the resulting expression. You can also use Fixpoint to apply the rules until there are no changes.","category":"page"},{"location":"interface/#Interfacing-with-Metatheory.jl","page":"Interfacing with Metatheory.jl","title":"Interfacing with Metatheory.jl","text":"","category":"section"},{"location":"interface/","page":"Interfacing with Metatheory.jl","title":"Interfacing with Metatheory.jl","text":"This section is for Julia package developers who may want to use the rule rewriting systems on their own expression types.","category":"page"},{"location":"interface/#Defining-the-interface","page":"Interfacing with Metatheory.jl","title":"Defining the interface","text":"","category":"section"},{"location":"interface/","page":"Interfacing with Metatheory.jl","title":"Interfacing with Metatheory.jl","text":"Metatheory.jl matchers can match any Julia object that implements an interface to traverse it as a tree. The interface in question, is defined in the TermInterface.jl package. Its purpose is to provide a shared interface between various symbolic programming Julia packages. ","category":"page"},{"location":"interface/","page":"Interfacing with Metatheory.jl","title":"Interfacing with Metatheory.jl","text":"In particular, you should define methods from TermInterface.jl for an expression tree type T with symbol types S to  work with SymbolicUtils.jl","category":"page"},{"location":"interface/","page":"Interfacing with Metatheory.jl","title":"Interfacing with Metatheory.jl","text":"You can read the documentation of TermInterface.jl on the Github repository.","category":"page"},{"location":"egraphs/#EGraphs-and-Equality-Saturation","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"An EGraph is an efficient data structure for representing congruence relations. EGraphs are data structures originating from theorem provers. Several projects have very recently repurposed EGraphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers using a technique known as equality saturation. Metatheory.jl provides a general purpose, customizable implementation of EGraphs and equality saturation, inspired from the egg library for Rust. You can read more about the design of the EGraph data structure and equality saturation algorithm in the egg paper.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"See Alessandro Cheli and Philip Zucker's  talk at JuliaCon 2021 for an overview of the concepts introduced in this chapter of the manual (NOTE: Syntax in the talk slideshow is out of date).","category":"page"},{"location":"egraphs/#What-can-I-do-with-EGraphs-in-Metatheory.jl?","page":"EGraphs and Equality Saturation","title":"What can I do with EGraphs in Metatheory.jl?","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"In classical term rewriting, rewrites are typically destructive and forget the matched left-hand side. Therefore, rules are applied in an arbitrary or controlled order - this often results in local minima and looping. For decades, programmers and scientists using term rewriting systems have spent their time trying to find confluent and terminating systems of rules. This requires a lot of effort and time. When studying any computational, mathematical or scientific system governed by equational rules, about non obviously oriented equations, such as (a + b) + c = a + (b + c )?","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"E-Graphs come to our help.  EGraphs are bipartite graphs of ENodes and EClasses: a data structure for efficiently represent and rewrite on many equivalent expressions at the same time. A sort of fast data structure for sets of trees. Subtrees and parents are shared if possible. This makes EGraphs similar to DAGs. Most importantly, with EGraph rewriting you can use bidirectional rewrite rules, such as equalities without worrying about the ordering and confluence of your rewrite system! Therefore, rule application in EGraphs is non-destructive - everything is copied! This allows users to run non-deterministic rewrite systems. Many rules can match at the same time and the previous state of expressions will not be lost.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The EGraph backend for Metatheory.jl allows you to create an EGraph from a starting expression, to add more expressions to the EGraph with addexpr!, and then to effectively fill the EGraph with all possible equivalent expressions resulting from applying rewrite rules from a theory, by using the saturate! function. You can then easily extract expressions from an e-graph by calling extract! with a cost function.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"A killer feature of egg and Metatheory.jl are EGraph Analyses. They allow you to annotate expressions and equivalence classes in an EGraph with values from a semilattice domain, and then to:","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Automatically extract optimal expressions from an EGraph deciding from analysis data.\nHave conditional rules that are executed if some criteria is met on analysis data\nHave dynamic rules that compute the right hand side based on analysis data.","category":"page"},{"location":"egraphs/#Library","page":"EGraphs and Equality Saturation","title":"Library","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The Metatheory.Library module contains utility functions and macros for creating rules and theories from commonly used algebraic structures and properties, to be used with the e-graph backend.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"using Metatheory.Library\n\ncomm_monoid = @commutative_monoid (*) 1","category":"page"},{"location":"egraphs/#Theories-and-Algebraic-Structures","page":"EGraphs and Equality Saturation","title":"Theories and Algebraic Structures","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The e-graphs backend can directly handle associativity, equalities commutativity and distributivity, rules that are otherwise known of causing loops and require extensive user reasoning  in classical rewriting.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"t = @theory a b c begin\n    a * b == b * a\n    a * 1 == a\n    a * (b * c) == (a * b) * c\nend","category":"page"},{"location":"egraphs/#Equality-Saturation","page":"EGraphs and Equality Saturation","title":"Equality Saturation","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"We can programmatically build and saturate an EGraph. The function saturate! takes an EGraph and a theory, and executes equality saturation. Returns a report of the equality saturation process. saturate! is configurable, customizable parameters include a timeout on the number of iterations, a eclasslimit on the number of e-classes in the EGraph, a stopwhen functions that stops saturation when it evaluates to true.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"g = EGraph(:((a * b) * (1 * (b + c))));\nreport = saturate!(G, t);\n# access the saturated EGraph\nreport.egraph\n\n# show some fancy stats\nreport","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Equality Saturation Report\n=================\n        Stop Reason: saturated\n        Iterations: 1\n        EGraph Size: 9 eclasses, 51 nodes\n ───────────────────────────────────────────────────────────────────────────────────────\n                                                Time                   Allocations      \n                                        ──────────────────────   ───────────────────────\n            Tot / % measured:                1.18s / 0.45%            955KiB / 68.1%    \n\n Section                        ncalls     time   %tot     avg     alloc   %tot      avg\n ───────────────────────────────────────────────────────────────────────────────────────\n Apply                               1   4.63ms  87.5%  4.63ms    512KiB  78.7%   512KiB\n Search                              1    656μs  12.4%   656μs    139KiB  21.3%   139KiB\n   a * (b * c) == (a * b) * c        1    242μs  4.58%   242μs   79.2KiB  12.2%  79.2KiB\n   a * b == b * a                    1    153μs  2.89%   153μs   34.2KiB  5.26%  34.2KiB\n   a * 1 == a                        1    115μs  2.17%   115μs   14.4KiB  2.21%  14.4KiB\n   appending matches                 3   4.06μs  0.08%  1.35μs      544B  0.08%     181B\n Rebuild                             1   3.75μs  0.07%  3.75μs     0.00B  0.00%    0.00B\n ───────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"With the EGraph equality saturation backend, Metatheory.jl can prove simple equalities very efficiently. The @areequal macro takes a theory and some expressions and returns true iff the expressions are equal according to the theory. The following example may return true with an appropriate example theory. ","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"julia> @areequal some_theory (x+y)*(a+b) ((a*(x+y))+b*(x+y)) ((x*(a+b))+y*(a+b)) ","category":"page"},{"location":"egraphs/#Configurable-Parameters","page":"EGraphs and Equality Saturation","title":"Configurable Parameters","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"EGraphs.saturate! can accept an additional parameter of type EGraphs.SaturationParams to configure the equality saturation algorithm. Extensive documentation for the configurable parameters is available in the EGraphs.SaturationParams API docstring.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"# create the saturation params\nparams = SaturationParams(timeout=10, eclasslimit=4000)\nsaturate!(egraph, theory, params)","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"CurrentModule = Base","category":"page"},{"location":"egraphs/#Outline-of-the-Equality-Saturation-Algorithm","page":"EGraphs and Equality Saturation","title":"Outline of the Equality Saturation Algorithm","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The saturate! function behaves as following. Given a starting e-graph g, a set of rewrite rules t and some parameters p (including an iteration limit n):","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"For each rule in t, search through the e-graph for l.h.s.\nFor each match produced, apply the rewrite\nDo a bottom-up traversal of the e-graph to rebuild the congruence closure\nIf the e-graph hasn’t changed from last iteration, it has saturated. If so, halt saturation.\nLoop at most n times.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Note that knowing if an expression with a set of rules saturates an e-graph or never terminates is still an open research problem","category":"page"},{"location":"egraphs/#Extracting-from-an-EGraph","page":"EGraphs and Equality Saturation","title":"Extracting from an EGraph","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Since e-graphs non-deterministically represent many equivalent symbolic terms, extracting an expression from an EGraph is the process of selecting and extracting a single symbolic expression from the set of all the possible expressions contained in the EGraph. Extraction is done through the extract! function, and the theoretical background behind this procedure is an EGraph Analysis; A cost function is provided as a parameter to the extract! function. This cost function will examine mostly every e-node in the e-graph and will determine which e-nodes will be chosen from each e-class through an automated, recursive algorithm.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Metatheory.jl already provides some simple cost functions, such as astsize, which expresses preference for the smallest expressions contained in equivalence classes.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Here's an example Given the theory:","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"using Metatheory\nusing Metatheory.Library\n\ncomm_monoid = @commutative_monoid (*) 1;\nt = @theory a b c begin\n    a + 0 --> a\n    a + b --> b + a\n    a + inv(a) --> 0 # inverse\n    a + (b + c) --> (a + b) + c\n\ta * (b + c) --> (a * b) + (a * c)\n\t(a * b) + (a * c) --> a * (b + c)\n\ta * a --> a^2\n\ta --> a^1\n\ta^b * a^c --> a^(b+c)\n\tlog(a^b) --> b * log(a)\n\tlog(a * b) --> log(a) + log(b)\n\tlog(1) --> 0\n\tlog(:e) --> 1\n\t:e^(log(a)) --> a\n\ta::Number + b::Number => a + b\n\ta::Number * b::Number => a * b\nend\nt = comm_monoid ∪ t ;\nnothing # hide","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"We can extract an expression by using","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"\nexpr = :((log(e) * log(e)) * (log(a^3 * a^2)))\ng = EGraph(expr)\nsaturate!(g, t)\nex = extract!(g, astsize)","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The second argument to extract! is a cost function. astsize is  a cost function provided by default, which computes the size of expressions.","category":"page"},{"location":"egraphs/#Defining-custom-cost-functions-for-extraction.","page":"EGraphs and Equality Saturation","title":"Defining custom cost functions for extraction.","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"A cost function for EGraph extraction is a function used to determine which e-node will be extracted from an e-class. ","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"It must return a positive, non-complex number value and, must accept 3 arguments.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The current ENode n that is being inspected. \nThe current EGraph g.\nThe current analysis type an.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"From those 3 parameters, one can access all the data needed to compute the cost of an e-node recursively.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"One can use TermInterface.jl methods to access the operation and child arguments of an e-node: operation(n), arity(n) and arguments(n)\nSince e-node children always point to e-classes in the same e-graph, one can retrieve the EClass object for each child of the currently visited enode with g[id] for id in arguments(n)\nOne can inspect the analysis data for a given eclass and a given analysis type an, by using hasdata and getdata.\nExtraction analyses always associate a tuple of 2 values to a single e-class: which e-node is the one that minimizes the cost","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"and its cost. More details can be found in the egg paper in the Analyses section. ","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Here's an example:","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"# This is a cost function that behaves like `astsize` but increments the cost \n# of nodes containing the `^` operation. This results in a tendency to avoid \n# extraction of expressions containing '^'.\nfunction cost_function(n::ENodeTerm, g::EGraph, an::Type{<:AbstractAnalysis})\n    cost = 1 + arity(n)\n\n    operation(n) == :^ && (cost += 2)\n\n    for id in arguments(n)\n        eclass = g[id]\n        # if the child e-class has not yet been analyzed, return +Inf\n        !hasdata(eclass, an) && (cost += Inf; break)\n        cost += last(getdata(eclass, an))\n    end\n    return cost\nend\n\n# All literal expressions (e.g `a`, 123, 0.42, \"hello\") have cost 1\ncost_function(n::ENodeLiteral, g::EGraph, an::Type{<:AbstractAnalysis}) = 1","category":"page"},{"location":"egraphs/#EGraph-Analyses","page":"EGraphs and Equality Saturation","title":"EGraph Analyses","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"An EGraph Analysis is an efficient and automated way of analyzing all the possible terms contained in an e-graph. Metatheory.jl provides a toolkit to ease and  automate the process of EGraph Analysis. An EGraph Analysis defines a domain of values and associates a value from the domain to each EClass in the graph. Theoretically, the domain should form a join semilattice. Rewrites can cooperate with e-class analyses by depending on analysis facts and adding equivalences that in turn establish additional facts. ","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"In Metatheory.jl, EGraph Analyses are identified by a type that is subtype of AbstractAnalysis. An EGraph can only contain one analysis per type. The following functions define an interface for analyses based on multiple dispatch  on AbstractAnalysis types: ","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"islazy should return true if the analysis should NOT be computed on-the-fly during egraphs operation, only when required.  \nmake should take an ENode and return a value from the analysis domain.\njoin should return the semilattice join of two values in the analysis domain (e.g. given two analyses value from ENodes in the same EClass, which one should I choose?)\nmodify! Can be optionally implemented. Can be used modify an EClass on-the-fly given its analysis value.","category":"page"},{"location":"egraphs/#Defining-a-custom-analysis","page":"EGraphs and Equality Saturation","title":"Defining a custom analysis","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"In this example, we will provide a custom analysis that tags each EClass in an EGraph with :even if it contains an even number or with :odd if it represents an odd number, or nothing if it does not contain a number at all. Let's suppose that the language of the symbolic expressions that we are considering will contain only integer numbers, variable symbols and the `and+` operations.*","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Since we are in a symbolic computation context, we are not interested in the the actual numeric result of the expressions in the EGraph, but we only care to analyze and identify the symbolic expressions that will result in an even or an odd number.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Defining an EGraph Analysis is similar to the process Mathematical Induction. To define a custom EGraph Analysis, one should start by defining a type that  subtypes AbstractAnalysis that will be used to identify this specific analysis and  to dispatch against the required methods.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"using Metatheory\nusing Metatheory.EGraphs\nabstract type OddEvenAnalysis <: AbstractAnalysis end","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The next step, the base case of induction, is to define a method for make dispatching against our OddEvenAnalysis. First, we want to associate an analysis value only to the literals contained in the EGraph. To do this we take advantage of multiple dispatch against ENodeLiteral.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"function EGraphs.make(an::Type{OddEvenAnalysis}, g::EGraph, n::ENodeLiteral)\n    if n.value isa Integer\n        return iseven(n.value) ? :even : :odd\n    else \n        return nothing\n    end\nend","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Now we have to consider the induction step.  Knowing that our language contains only * and + operations, and knowing that:","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"odd * odd = odd\nodd * even = even\neven * even = even","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"And we know that ","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"odd + odd = even \nodd + even = odd \neven + even = even","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"We can now define a method for make dispatching against  OddEvenAnalysis and ENodeTerms to compute the analysis value for nested symbolic terms.  We take advantage of the methods in TermInterface  to inspect the content of an ENodeTerm. From the definition of an ENode, we know that children of ENodes are always IDs pointing to EClasses in the EGraph.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"function EGraphs.make(an::Type{OddEvenAnalysis}, g::EGraph, n::ENodeTerm)\n    # Let's consider only binary function call terms.\n    if exprhead(n) == :call && arity(n) == 2\n        op = operation(n)\n        # Get the left and right child eclasses\n        child_eclasses = arguments(n)\n        l = g[child_eclasses[1]]\n        r = g[child_eclasses[2]]\n\n        # Get the corresponding OddEvenAnalysis value of the children\n        # defaulting to nothing \n        ldata = getdata(l, an, nothing)\n        rdata = getdata(r, an, nothing)\n\n        if ldata isa Symbol && rdata isa Symbol\n            if op == :*\n                return (ldata == :even || rdata == :even) ? :even : :odd\n            elseif op == :+\n                return (ldata == rdata) ? :even : :odd\n            end\n        elseif isnothing(ldata) && rdata isa Symbol && op == :*\n            return rdata\n        elseif ldata isa Symbol && isnothing(rdata) && op == :*\n            return ldata\n        end\n    end\n\n    return nothing\nend","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"We have now defined a way of tagging each ENode in the EGraph with :odd or :even, reasoning  inductively on the analyses values. The analyze! function will do the dirty job of doing  a recursive walk over the EGraph. The missing piece, is now telling Metatheory.jl how to merge together analysis values. Since EClasses represent many equal ENodes, we have to inform the automated analysis how to extract a single value out of the many analyses values contained in an EGraph. We do this by defining a method for join.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"function EGraphs.join(an::Type{OddEvenAnalysis}, a, b)\n    if a == b \n        return a \n    else\n        # an expression cannot be odd and even at the same time!\n        # this is contradictory, so we ignore the analysis value\n        return nothing \n    end\nend","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"We do not care to modify the content of EClasses in consequence of our analysis. Therefore, we can skip the definition of modify!. We are now ready to test our analysis.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"t = @theory a b c begin \n    a * (b * c) == (a * b) * c\n    a + (b + c) == (a + b) + c\n    a * b == b * a\n    a + b == b + a\n    a * (b + c) == (a * b) + (a * c)\nend\n\nfunction custom_analysis(expr)\n    g = EGraph(expr)\n    saturate!(g, t)\n    analyze!(g, OddEvenAnalysis)\n    return getdata(g[g.root], OddEvenAnalysis)\nend\n\ncustom_analysis(:(3*a)) # :odd\ncustom_analysis(:(3*(2+a)*2)) # :even\ncustom_analysis(:(3y * (2x*y))) # :even","category":"page"},{"location":"#Metatheory.jl-1.0","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"<p align=\"center\">\n<img width=\"400px\" src=\"https://raw.githubusercontent.com/juliasymbolics/Metatheory.jl/master/docs/src/assets/dragon.jpg\"/>\n</p>","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"(Image: Docs) (Image: Docs) (Image: CI) (Image: codecov) (Image: arXiv) (Image: status) (Image: Zulip)","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"Metatheory.jl is a general purpose term rewriting, metaprogramming and algebraic computation library for the Julia programming language, designed to take advantage of the powerful reflection capabilities to bridge the gap between symbolic mathematics, abstract interpretation, equational reasoning, optimization, composable compiler transforms, and advanced homoiconic pattern matching features. The core features of Metatheory.jl are a powerful rewrite rule definition language, a vast library of functional combinators for classical term rewriting and an e-graph rewriting, a fresh approach to term rewriting achieved through an equality saturation algorithm. Metatheory.jl can manipulate any kind of Julia symbolic expression type, as long as it satisfies the TermInterface.jl.","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"Metatheory.jl provides:","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"An eDSL (domain specific language) to define different kinds of symbolic rewrite rules.\nA classical rewriting backend, derived from the SymbolicUtils.jl pattern matcher, supporting associative-commutative rules. It is based on the pattern matcher in the SICM book.\nA flexible library of rewriter combinators.\nAn e-graph rewriting (equality saturation) backend and pattern matcher, based on the egg library, supporting backtracking and non-deterministic term rewriting by using a data structure called e-graph, efficiently incorporating the notion of equivalence in order to reduce the amount of user effort required to achieve optimization tasks and equational reasoning.\n@capture macro for flexible metaprogramming.","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"Intuitively, Metatheory.jl transforms Julia expressions in other Julia expressions and can achieve such at both compile and run time. This allows Metatheory.jl users to perform customized and composable compiler optimizations specifically tailored to single, arbitrary Julia packages. Our library provides a simple, algebraically composable interface to help scientists in implementing and reasoning about semantics and all kinds of formal systems, by defining concise rewriting rules in pure, syntactically valid Julia on a high level of abstraction. Our implementation of equality saturation on e-graphs is based on the excellent, state-of-the-art technique implemented in the egg library, reimplemented in pure Julia.","category":"page"},{"location":"#.0-is-out!","page":"Metatheory.jl 1.0","title":"1.0 is out!","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"The first stable version of Metatheory.jl is out! The goal of this release is to unify the symbolic manipulation ecosystem of Julia packages. Many features have been ported from SymbolicUtils.jl. Now, Metatheory.jl can be used in place of SymbolicUtils.jl when you have no need of manipulating mathematical expressions. SymbolicUtils.jl can now completely leverage on the generic stack of rewriting features provided by Metatheory.jl, highly decoupled from the symbolic term representation thanks to TermInterface.jl. Read more in NEWS.md.","category":"page"},{"location":"#Recommended-Readings-Selected-Publications","page":"Metatheory.jl 1.0","title":"Recommended Readings - Selected Publications","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"The Metatheory.jl manual \nThe Metatheory.jl introductory paper gives a brief high level overview on the library and its functionalities.\nThe Julia Manual metaprogramming section is fundamental to understand what homoiconic expression manipulation is and how it happens in Julia.\nAn introductory blog post on SIGPLAN about egg and e-graphs rewriting.\negg: Fast and Extensible Equality Saturation contains the definition of E-Graphs on which Metatheory.jl's equality saturation rewriting backend is based. This is a strongly recommended reading.\nHigh-performance symbolic-numerics via multiple dispatch: a paper about how we used Metatheory.jl to optimize code generation in Symbolics.jl","category":"page"},{"location":"#Contributing","page":"Metatheory.jl 1.0","title":"Contributing","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"If you'd like to give us a hand and contribute to this repository you can:","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"Find a high level description of the project architecture in ARCHITECTURE.md\nRead the contribution guidelines in CONTRIBUTING.md","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"If you enjoyed Metatheory.jl and would like to help, please also consider a tiny donation 💕!","category":"page"},{"location":"#Installation","page":"Metatheory.jl 1.0","title":"Installation","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"You can install the stable version:","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"julia> using Pkg; Pkg.add(\"Metatheory\")","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"Or you can install the developer version (recommended by now for latest bugfixes)","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/JuliaSymbolics/Metatheory.jl\")","category":"page"},{"location":"#Documentation","page":"Metatheory.jl 1.0","title":"Documentation","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"Extensive Metatheory.jl is available here","category":"page"},{"location":"#Citing","page":"Metatheory.jl 1.0","title":"Citing","text":"","category":"section"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"If you use Metatheory.jl in your research, please cite our works.","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"","category":"page"},{"location":"","page":"Metatheory.jl 1.0","title":"Metatheory.jl 1.0","text":"<p align=\"center\">\n<a href=\"https://planting.space\"> \n    <img width=\"300px\" src=\"https://raw.githubusercontent.com/juliasymbolics/Metatheory.jl/master/.github/plantingspace.png\"/>\n</a>\n</p>","category":"page"}]
}
