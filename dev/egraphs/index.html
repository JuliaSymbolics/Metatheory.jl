<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EGraphs and Equality Saturation · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl 2.0</a></li><li><a class="tocitem" href="../rewrite/">Classical Term Rewriting</a></li><li class="is-active"><a class="tocitem" href>EGraphs and Equality Saturation</a><ul class="internal"><li><a class="tocitem" href="#What-can-I-do-with-EGraphs-in-Metatheory.jl?"><span>What can I do with EGraphs in Metatheory.jl?</span></a></li><li><a class="tocitem" href="#Library"><span>Library</span></a></li><li><a class="tocitem" href="#Equality-Saturation"><span>Equality Saturation</span></a></li><li><a class="tocitem" href="#Configurable-Parameters"><span>Configurable Parameters</span></a></li><li><a class="tocitem" href="#Outline-of-the-Equality-Saturation-Algorithm"><span>Outline of the Equality Saturation Algorithm</span></a></li><li><a class="tocitem" href="#Extracting-from-an-EGraph"><span>Extracting from an EGraph</span></a></li><li><a class="tocitem" href="#Defining-custom-cost-functions-for-extraction."><span>Defining custom cost functions for extraction.</span></a></li><li><a class="tocitem" href="#EGraph-Analyses"><span>EGraph Analyses</span></a></li></ul></li><li><a class="tocitem" href="../visualizing/">Visualizing E-Graphs</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/calculational_logic/">Rewriting Calculational Logic</a></li><li><a class="tocitem" href="../tutorials/custom_types/">Interfacing with Metatheory.jl</a></li><li><a class="tocitem" href="../tutorials/fibonacci/">Benchmarking Fibonacci. E-Graphs memoize computation.</a></li><li><a class="tocitem" href="../tutorials/mu/">The MU Puzzle</a></li><li><a class="tocitem" href="../tutorials/propositional_logic/">Rewriting</a></li><li><a class="tocitem" href="../tutorials/while_interpreter/">Write a very tiny Turing Complete language in Julia.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>EGraphs and Equality Saturation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>EGraphs and Equality Saturation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/master/docs/src/egraphs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="EGraphs-and-Equality-Saturation"><a class="docs-heading-anchor" href="#EGraphs-and-Equality-Saturation">EGraphs and Equality Saturation</a><a id="EGraphs-and-Equality-Saturation-1"></a><a class="docs-heading-anchor-permalink" href="#EGraphs-and-Equality-Saturation" title="Permalink"></a></h1><p>An <em>EGraph</em> is an efficient data structure for representing congruence relations. EGraphs are data structures originating from theorem provers. Several projects have very recently repurposed EGraphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers using a technique known as equality saturation. Metatheory.jl provides a general purpose, customizable implementation of EGraphs and equality saturation, inspired from the <a href="https://egraphs-good.github.io/">egg</a> library for Rust. You can read more about the design of the EGraph data structure and equality saturation algorithm in the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a>.</p><p>Let&#39;s load Metatheory and the rule library</p><pre><code class="language-julia">using Metatheory
using Metatheory.Library</code></pre><h2 id="What-can-I-do-with-EGraphs-in-Metatheory.jl?"><a class="docs-heading-anchor" href="#What-can-I-do-with-EGraphs-in-Metatheory.jl?">What can I do with EGraphs in Metatheory.jl?</a><a id="What-can-I-do-with-EGraphs-in-Metatheory.jl?-1"></a><a class="docs-heading-anchor-permalink" href="#What-can-I-do-with-EGraphs-in-Metatheory.jl?" title="Permalink"></a></h2><p>In classical term rewriting, rewrites are typically destructive and forget the matched left-hand side. Therefore, rules are applied in an arbitrary or controlled order - this often results in local minima and looping. For decades, programmers and scientists using term rewriting systems have spent their time trying to find confluent and terminating systems of rules. This requires a lot of effort and time. When studying any computational, mathematical or scientific system governed by equational rules, about non obviously oriented equations, such as <code>(a + b) + c = a + (b + c )</code>?</p><p>E-Graphs come to our help.  EGraphs are bipartite graphs of <a href="@ref">ENode</a>s and <a href="@ref">EClass</a>es: a data structure for efficiently represent and rewrite on many equivalent expressions at the same time. A sort of fast data structure for sets of trees. Subtrees and parents are shared if possible. This makes EGraphs similar to DAGs. Most importantly, with EGraph rewriting you can use <strong>bidirectional rewrite rules</strong>, such as <strong>equalities</strong> without worrying about the ordering and confluence of your rewrite system! Therefore, rule application in EGraphs is non-destructive - everything is copied! This allows users to run non-deterministic rewrite systems. Many rules can match at the same time and the previous state of expressions will not be lost.</p><p>The EGraph backend for Metatheory.jl allows you to create an EGraph from a starting expression, to add more expressions to the EGraph with <code>addexpr!</code>, and then to effectively fill the EGraph with all possible equivalent expressions resulting from applying rewrite rules from a <a href="../rewrite#Theories">theory</a>, by using the <code>saturate!</code> function. You can then easily extract expressions from an e-graph by calling <code>extract!</code> with a cost function.</p><p>A killer feature of <a href="https://egraphs-good.github.io/">egg</a> and Metatheory.jl are <strong>EGraph Analyses</strong>. They allow you to annotate expressions and equivalence classes in an EGraph with values from a semilattice domain, and then to:</p><ul><li>Automatically extract optimal expressions from an EGraph deciding from analysis data.</li><li>Have conditional rules that are executed if some criteria is met on analysis data</li><li>Have dynamic rules that compute the right hand side based on analysis data.</li></ul><h2 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h2><p>The <code>Metatheory.Library</code> module contains utility functions and macros for creating rules and theories from commonly used algebraic structures and properties, to be used with the e-graph backend.</p><pre><code class="language-julia">comm_monoid = @commutative_monoid (*) 1

# output

4-element Vector{RewriteRule}:
 ~a * ~b --&gt; ~b * ~a
 (~a * ~b) * ~c --&gt; ~a * (~b * ~c)
 ~a * (~b * ~c) --&gt; (~a * ~b) * ~c
 1 * ~a --&gt; ~a
</code></pre><h4 id="Theories-and-Algebraic-Structures"><a class="docs-heading-anchor" href="#Theories-and-Algebraic-Structures">Theories and Algebraic Structures</a><a id="Theories-and-Algebraic-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Theories-and-Algebraic-Structures" title="Permalink"></a></h4><p><strong>The e-graphs backend can directly handle associativity, equalities commutativity and distributivity</strong>, rules that are otherwise known of causing loops and require extensive user reasoning  in classical rewriting.</p><pre><code class="language-julia">t = @theory a b c begin
    a * b == b * a
    a * 1 == a
    a * (b * c) == (a * b) * c
end

# output

3-element Vector{EqualityRule}:
 ~a * ~b == ~b * ~a
 ~a * 1 == ~a
 ~a * (~b * ~c) == (~a * ~b) * ~c
</code></pre><h2 id="Equality-Saturation"><a class="docs-heading-anchor" href="#Equality-Saturation">Equality Saturation</a><a id="Equality-Saturation-1"></a><a class="docs-heading-anchor-permalink" href="#Equality-Saturation" title="Permalink"></a></h2><p>We can programmatically build and saturate an EGraph. The function <code>saturate!</code> takes an <code>EGraph</code> and a theory, and executes equality saturation. Returns a report of the equality saturation process. <code>saturate!</code> is configurable, customizable parameters include a <code>timeout</code> on the number of iterations, a <code>eclasslimit</code> on the number of e-classes in the EGraph, a <code>stopwhen</code> functions that stops saturation when it evaluates to true.</p><pre><code class="language-">g = EGraph(:((a * b) * (1 * (b + c))));
report = saturate!(g, t);</code></pre><p>With the EGraph equality saturation backend, Metatheory.jl can prove <strong>simple</strong> equalities very efficiently. The <code>@areequal</code> macro takes a theory and some expressions and returns true iff the expressions are equal according to the theory. The following example may return true with an appropriate example theory. </p><pre><code class="language-julia">julia&gt; @areequal some_theory (x+y)*(a+b) ((a*(x+y))+b*(x+y)) ((x*(a+b))+y*(a+b)) </code></pre><h2 id="Configurable-Parameters"><a class="docs-heading-anchor" href="#Configurable-Parameters">Configurable Parameters</a><a id="Configurable-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Configurable-Parameters" title="Permalink"></a></h2><p><a href="../api/#Metatheory.EGraphs.saturate!"><code>EGraphs.saturate!</code></a> can accept an additional parameter of type <a href="../api/#Metatheory.EGraphs.SaturationParams"><code>EGraphs.SaturationParams</code></a> to configure the equality saturation algorithm. Extensive documentation for the configurable parameters is available in the <a href="../api/#Metatheory.EGraphs.SaturationParams"><code>EGraphs.SaturationParams</code></a> API docstring.</p><pre><code class="language-julia"># create the saturation params
params = SaturationParams(timeout=10, eclasslimit=4000)
saturate!(egraph, theory, params)</code></pre><h2 id="Outline-of-the-Equality-Saturation-Algorithm"><a class="docs-heading-anchor" href="#Outline-of-the-Equality-Saturation-Algorithm">Outline of the Equality Saturation Algorithm</a><a id="Outline-of-the-Equality-Saturation-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Outline-of-the-Equality-Saturation-Algorithm" title="Permalink"></a></h2><p>The <code>saturate!</code> function behaves as following. Given a starting e-graph <code>g</code>, a set of rewrite rules <code>t</code> and some parameters <code>p</code> (including an iteration limit <code>n</code>):</p><ul><li>For each rule in <code>t</code>, search through the e-graph for l.h.s.</li><li>For each match produced, apply the rewrite</li><li>Do a bottom-up traversal of the e-graph to rebuild the congruence closure</li><li>If the e-graph hasn’t changed from last iteration, it has saturated. If so, halt saturation.</li><li>Loop at most n times.</li></ul><p>Note that knowing if an expression with a set of rules saturates an e-graph or never terminates is still an open research problem</p><h2 id="Extracting-from-an-EGraph"><a class="docs-heading-anchor" href="#Extracting-from-an-EGraph">Extracting from an EGraph</a><a id="Extracting-from-an-EGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-from-an-EGraph" title="Permalink"></a></h2><p>Since e-graphs non-deterministically represent many equivalent symbolic terms, extracting an expression from an EGraph is the process of selecting and extracting a single symbolic expression from the set of all the possible expressions contained in the EGraph. Extraction is done through the <code>extract!</code> function, and the theoretical background behind this procedure is an <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">EGraph Analysis</a>; A cost function is provided as a parameter to the <code>extract!</code> function. This cost function will examine mostly every e-node in the e-graph and will determine which e-nodes will be chosen from each e-class through an automated, recursive algorithm.</p><p>Metatheory.jl already provides some simple cost functions, such as <code>astsize</code>, which expresses preference for the smallest expressions contained in equivalence classes.</p><p>Here&#39;s an example Given the theory:</p><pre><code class="language-julia">using Metatheory
using Metatheory.Library

comm_monoid = @commutative_monoid (*) 1;
t = @theory a b c begin
    a + 0 --&gt; a
    a + b --&gt; b + a
    a + inv(a) --&gt; 0 # inverse
    a + (b + c) --&gt; (a + b) + c
	a * (b + c) --&gt; (a * b) + (a * c)
	(a * b) + (a * c) --&gt; a * (b + c)
	a * a --&gt; a^2
	a --&gt; a^1
	a^b * a^c --&gt; a^(b+c)
	log(a^b) --&gt; b * log(a)
	log(a * b) --&gt; log(a) + log(b)
	log(1) --&gt; 0
	log(:e) --&gt; 1
	:e^(log(a)) --&gt; a
	a::Number + b::Number =&gt; a + b
	a::Number * b::Number =&gt; a * b
end
t = comm_monoid ∪ t ;</code></pre><p>We can extract an expression by using</p><pre><code class="language-julia">expr = :((log(e) * log(e)) * (log(a^3 * a^2)))
g = EGraph(expr)
saturate!(g, t)
ex = extract!(g, astsize)</code></pre><pre class="documenter-example-output">:(log(a ^ 5))</pre><p>The second argument to <code>extract!</code> is a <strong>cost function</strong>. <a href="@ref">astsize</a> is  a cost function provided by default, which computes the size of expressions.</p><h2 id="Defining-custom-cost-functions-for-extraction."><a class="docs-heading-anchor" href="#Defining-custom-cost-functions-for-extraction.">Defining custom cost functions for extraction.</a><a id="Defining-custom-cost-functions-for-extraction.-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-custom-cost-functions-for-extraction." title="Permalink"></a></h2><p>A <em>cost function</em> for <em>EGraph extraction</em> is a function used to determine which <em>e-node</em> will be extracted from an <em>e-class</em>. </p><p>It must return a positive, non-complex number value and, must accept 3 arguments.</p><ol><li>The current <a href="@ref">ENode</a> <code>n</code> that is being inspected. </li><li>The current <a href="@ref">EGraph</a> <code>g</code>.</li><li>The current analysis name <code>an::Symbol</code>.</li></ol><p>From those 3 parameters, one can access all the data needed to compute the cost of an e-node recursively.</p><ul><li>One can use <a href="https://github.com/JuliaSymbolics/TermInterface.jl">TermInterface.jl</a> methods to access the operation and child arguments of an e-node: <code>operation(n)</code>, <code>arity(n)</code> and <code>arguments(n)</code></li><li>Since e-node children always point to e-classes in the same e-graph, one can retrieve the <a href="@ref">EClass</a> object for each child of the currently visited enode with <code>g[id] for id in arguments(n)</code></li><li>One can inspect the analysis data for a given eclass and a given analysis name <code>an</code>, by using <a href="@ref">hasdata</a> and <a href="@ref">getdata</a>.</li><li>Extraction analyses always associate a tuple of 2 values to a single e-class: which e-node is the one that minimizes the cost</li></ul><p>and its cost. More details can be found in the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> in the <em>Analyses</em> section. </p><p>Here&#39;s an example:</p><pre><code class="language-julia"># This is a cost function that behaves like `astsize` but increments the cost 
# of nodes containing the `^` operation. This results in a tendency to avoid 
# extraction of expressions containing &#39;^&#39;.
function cost_function(n::ENodeTerm, g::EGraph)
    cost = 1 + arity(n)

    operation(n) == :^ &amp;&amp; (cost += 2)

    for id in arguments(n)
        eclass = g[id]
        # if the child e-class has not yet been analyzed, return +Inf
        !hasdata(eclass, cost_function) &amp;&amp; (cost += Inf; break)
        cost += last(getdata(eclass, cost_function))
    end
    return cost
end

# All literal expressions (e.g `a`, 123, 0.42, &quot;hello&quot;) have cost 1
cost_function(n::ENodeLiteral, g::EGraph) = 1</code></pre><h2 id="EGraph-Analyses"><a class="docs-heading-anchor" href="#EGraph-Analyses">EGraph Analyses</a><a id="EGraph-Analyses-1"></a><a class="docs-heading-anchor-permalink" href="#EGraph-Analyses" title="Permalink"></a></h2><p>An <em>EGraph Analysis</em> is an efficient and automated way of analyzing all the possible terms contained in an e-graph. Metatheory.jl provides a toolkit to ease and  automate the process of EGraph Analysis. </p><p>An <em>EGraph Analysis</em> defines a domain of values and associates a value from the domain to each <a href="@ref">EClass</a> in the graph. Theoretically, the domain should form a <a href="https://en.wikipedia.org/wiki/Semilattice">join semilattice</a>.  Rewrites can cooperate with e-class analyses by depending on analysis facts and adding equivalences that in turn establish additional facts. </p><p>In Metatheory.jl, <strong>EGraph Analyses are uniquely identified</strong> by either</p><ul><li>An unique name of type <code>Symbol</code>. </li><li>A function object <code>f</code>, used for cost function analysis. This will use built-in definitions of <code>make</code> and <code>join</code>.</li></ul><p>If you are specifying a custom analysis by its <code>Symbol</code> name,  the following functions define an interface for analyses based on multiple dispatch  on <code>Val{analysis_name::Symbol}</code>: </p><ul><li><a href="@ref">islazy(an)</a> should return true if the analysis name <code>an</code> should NOT be computed on-the-fly during egraphs operation, but only when inspected.  </li><li><a href="@ref">make(an, egraph, n)</a> should take an ENode <code>n</code> and return a value from the analysis domain.</li><li><a href="@ref">join(an, x,y)</a> should return the semilattice join of <code>x</code> and <code>y</code> in the analysis domain (e.g. <em>given two analyses value from ENodes in the same EClass, which one should I choose?</em>). If <code>an</code> is a <code>Function</code>, it is treated as a cost function analysis, it is automatically defined to be the minimum analysis value between <code>x</code> and <code>y</code>. Typically, the domain value of cost functions are real numbers, but if you really do want to have your own cost type, make sure that <code>Base.isless</code> is defined.</li><li><a href="@ref">modify!(an, egraph, eclassid)</a> Can be optionally implemented. This can be used modify an EClass <code>egraph[eclassid]</code> on-the-fly during an e-graph saturation iteration, given its analysis value.</li></ul><h3 id="Defining-a-custom-analysis"><a class="docs-heading-anchor" href="#Defining-a-custom-analysis">Defining a custom analysis</a><a id="Defining-a-custom-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-custom-analysis" title="Permalink"></a></h3><p>In this example, we will provide a custom analysis that tags each EClass in an EGraph with <code>:even</code> if it contains an even number or with <code>:odd</code> if it represents an odd number, or <code>nothing</code> if it does not contain a number at all. Let&#39;s suppose that the language of the symbolic expressions that we are considering will contain <em>only integer numbers, variable symbols and the `</em><code>and</code>+` operations.*</p><p>Since we are in a symbolic computation context, we are not interested in the the actual numeric result of the expressions in the EGraph, but we only care to analyze and identify the symbolic expressions that will result in an even or an odd number.</p><p>Defining an EGraph Analysis is similar to the process <a href="https://en.wikipedia.org/wiki/Mathematical_induction">Mathematical Induction</a>. To define a custom EGraph Analysis, one should start by defining a name of type <code>Symbol</code> that will be used to identify this specific analysis and to dispatch against the required methods.</p><pre><code class="language-julia">using Metatheory
using Metatheory.EGraphs</code></pre><p>The next step, the base case of induction, is to define a method for <a href="@ref">make</a> dispatching against our <code>OddEvenAnalysis</code>. First, we want to associate an analysis value only to the <em>literals</em> contained in the EGraph. To do this we take advantage of multiple dispatch against <code>ENodeLiteral</code>.</p><pre><code class="language-julia">function EGraphs.make(::Val{:OddEvenAnalysis}, g::EGraph, n::ENodeLiteral)
    if n.value isa Integer
        return iseven(n.value) ? :even : :odd
    else 
        return nothing
    end
end</code></pre><p>Now we have to consider the <em>induction step</em>.  Knowing that our language contains only <code>*</code> and <code>+</code> operations, and knowing that:</p><ul><li>odd * odd = odd</li><li>odd * even = even</li><li>even * even = even</li></ul><p>And we know that </p><ul><li>odd + odd = even </li><li>odd + even = odd </li><li>even + even = even</li></ul><p>We can now define a method for <code>make</code> dispatching against  <code>OddEvenAnalysis</code> and <code>ENodeTerm</code>s to compute the analysis value for <em>nested</em> symbolic terms.  We take advantage of the methods in <a href="https://github.com/JuliaSymbolics/TermInterface.jl">TermInterface</a>  to inspect the content of an <code>ENodeTerm</code>. From the definition of an <a href="@ref">ENode</a>, we know that children of ENodes are always IDs pointing to EClasses in the EGraph.</p><pre><code class="language-julia">function EGraphs.make(::Val{:OddEvenAnalysis}, g::EGraph, n::ENodeTerm)
    # Let&#39;s consider only binary function call terms.
    if exprhead(n) == :call &amp;&amp; arity(n) == 2
        op = operation(n)
        # Get the left and right child eclasses
        child_eclasses = arguments(n)
        l = g[child_eclasses[1]]
        r = g[child_eclasses[2]]

        # Get the corresponding OddEvenAnalysis value of the children
        # defaulting to nothing 
        ldata = getdata(l, :OddEvenAnalysis, nothing)
        rdata = getdata(r, :OddEvenAnalysis, nothing)

        if ldata isa Symbol &amp;&amp; rdata isa Symbol
            if op == :*
                if ldata == rdata
                    ldata
                elseif (ldata == :even || rdata == :even) 
                    :even
                else
                    nothing 
                end
            elseif op == :+
                (ldata == rdata) ? :even : :odd
            end
        elseif isnothing(ldata) &amp;&amp; rdata isa Symbol &amp;&amp; op == :*
            rdata
        elseif ldata isa Symbol &amp;&amp; isnothing(rdata) &amp;&amp; op == :*
            ldata
        end
    end

    return nothing
end</code></pre><p>We have now defined a way of tagging each ENode in the EGraph with <code>:odd</code> or <code>:even</code>, reasoning  inductively on the analyses values. The <a href="@ref">analyze!</a> function will do the dirty job of doing  a recursive walk over the EGraph. The missing piece, is now telling Metatheory.jl how to merge together analysis values. Since EClasses represent many equal ENodes, we have to inform the automated analysis how to extract a single value out of the many analyses values contained in an EGraph. We do this by defining a method for <a href="@ref">join</a>.</p><pre><code class="language-julia">function EGraphs.join(::Val{:OddEvenAnalysis}, a, b)
    if a == b 
        return a 
    else
        # an expression cannot be odd and even at the same time!
        # this is contradictory, so we ignore the analysis value
        return nothing 
    end
end</code></pre><p>We do not care to modify the content of EClasses in consequence of our analysis. Therefore, we can skip the definition of <a href="@ref">modify!</a>. We are now ready to test our analysis.</p><pre><code class="language-julia">t = @theory a b c begin 
    a * (b * c) == (a * b) * c
    a + (b + c) == (a + b) + c
    a * b == b * a
    a + b == b + a
    a * (b + c) == (a * b) + (a * c)
end

function custom_analysis(expr)
    g = EGraph(expr)
    saturate!(g, t)
    analyze!(g, OddEvenAnalysis)
    return getdata(g[g.root], OddEvenAnalysis)
end

custom_analysis(:(2*a)) # :even
custom_analysis(:(3*3)) # :odd
custom_analysis(:(3*(2+a)*2)) # :even
custom_analysis(:(3y * (2x*y))) # :even</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rewrite/">« Classical Term Rewriting</a><a class="docs-footer-nextpage" href="../visualizing/">Visualizing E-Graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 7 January 2024 20:05">Sunday 7 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
