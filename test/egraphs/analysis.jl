# example assuming * operation is always binary

# ENV["JULIA_DEBUG"] = Metatheory

using Metatheory
using Metatheory.Library

include("../../examples/prove.jl")

struct NumberFoldAnalysis
  n::Number
end

Base.:(*)(a::NumberFoldAnalysis, b::NumberFoldAnalysis) = NumberFoldAnalysis(a.n * b.n)
Base.:(+)(a::NumberFoldAnalysis, b::NumberFoldAnalysis) = NumberFoldAnalysis(a.n + b.n)

# This should be auto-generated by a macro
function EGraphs.make(g::EGraph{ExpressionType,NumberFoldAnalysis}, n::VecExpr) where {ExpressionType}
  h = get_constant(g, v_head(n))
  v_isexpr(n) || return h isa Number ? NumberFoldAnalysis(h) : nothing
  if v_iscall(n) && v_arity(n) == 2
    args = v_children(n)
    l, r = g[args[1]], g[args[2]]

    if l.data isa NumberFoldAnalysis && r.data isa NumberFoldAnalysis
      if h == :*
        return l.data * r.data
      elseif h == :+
        return l.data + r.data
      end
    end
  end
  # Could not analyze, returns nothing
end

function EGraphs.join(from::NumberFoldAnalysis, to::NumberFoldAnalysis)
  @assert from == to
  from
end

# Add the number to the eclass.
function EGraphs.modify!(
  g::EGraph{ExpressionType,NumberFoldAnalysis},
  eclass::EClass{NumberFoldAnalysis},
) where {ExpressionType}
  isnothing(eclass.data) || union!(g, addexpr!(g, eclass.data.n), find(g, eclass.id))
end


comm_monoid = @theory begin
  ~a * ~b --> ~b * ~a
  ~a * 1 --> ~a
  ~a * (~b * ~c) --> (~a * ~b) * ~c
end

g = EGraph{Expr,NumberFoldAnalysis}(:(3 * 4))


@testset "Basic Constant Folding Example - Commutative Monoid" begin
  @test test_equality(comm_monoid, :(3 * 4), 12; g)
  @test test_equality(comm_monoid, :(3 * 4), 12, :(4 * 3), :(6 * 2); g)
end

@testset "Basic Constant Folding Example 2 - Commutative Monoid" begin
  ex = :(a * 3 * b * 4)
  g = EGraph{Expr,NumberFoldAnalysis}(ex)
  addexpr!(g, :(12 * a))
  @test test_equality(comm_monoid, :((12 * a) * b), :(((6 * 2) * b) * a); g)
  @test test_equality(comm_monoid, :((3 * a) * (4 * b)), :((12 * a) * b), :(((6 * 2) * b) * a); g)
end

@testset "Basic Constant Folding Example - Adding analysis after saturation" begin
  g = EGraph{Expr,NumberFoldAnalysis}(:(3 * 4))
  # addexpr!(g, 12)
  saturate!(g, comm_monoid)
  addexpr!(g, :(a * 2))
  saturate!(g, comm_monoid)

  @test test_equality(comm_monoid, :(3 * 4), 12, :(4 * 3), :(6 * 2); g)

  ex = :(a * 3 * b * 4)
  g = EGraph{Expr,NumberFoldAnalysis}(ex)
  params = SaturationParams(timeout = 15)
  @test test_equality(comm_monoid, :((3 * a) * (4 * b)), :((12 * a) * b), :(((6 * 2) * b) * a); params, g)
end

@testset "Infinite Loops analysis" begin
  boson = @theory begin
    1 * ~x --> ~x
  end


  g = EGraph(:(1 * x))
  params = SaturationParams(timeout = 100)
  saturate!(g, boson, params)
  ex = extract!(g, astsize)


  boson = @theory begin
    (:c * :cdag) --> :cdag * :c + 1
    ~a * (~b + ~c) --> (~a * ~b) + (~a * ~c)
    (~b + ~c) * ~a --> (~b * ~a) + (~c * ~a)
    # 1 * x => x
    (~a * ~b) * ~c --> ~a * (~b * ~c)
    ~a * (~b * ~c) --> (~a * ~b) * ~c
  end

  g = EGraph(:(c * c * cdag * cdag))
  saturate!(g, boson)
  ex = extract!(g, astsize_inv)

end



@testset "Conditional Dynamic Rule" begin
  g = EGraph{Expr,NumberFoldAnalysis}()

  theo_dyn_cond = @theory a begin
    a => !isnothing(a.data) ? a.data.n : nothing # awkward rule to trigger a certain branch in saturation.jl
  end

  @test !test_equality(theo_dyn_cond, :x, :y, :z; g)
  @test !test_equality(theo_dyn_cond, 0, 1, 2; g)
end