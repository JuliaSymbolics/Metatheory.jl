@misc{rgf,
  author = {{Rackauckas}, C and {Foster}, C},
  title = {{RuntimeGeneratedFunctions.jl}: Functions generated at runtime without world-age issues},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/SciML/RuntimeGeneratedFunctions.jl}
}

@misc{mlstyle,
  author = {{Zhao}, T},
  title = {{MLStyle.jl}: Fast, consistent and extensible functional programming infrastructures},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/thautwarm/MLStyle.jl}
}


@misc{metatheory,
  author = {{Cheli}, Alessandro},
  title = {{Metatheory.jl}},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/0x0f0f0f/Metatheory.jl}
}

@misc{matchcore,
  author = {{Zhao}, T and {Carlsson}, K},
  title = {{MatchCore.jl}: A minimal implementation of optimized pattern matching.},
  year = {2020},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/thautwarm/MatchCore.jl}
}


@misc{datastruct,
  author = {{JuliaCollections}},
  title = {{DataStructures.jl}: Implementation for a variety of data structures.},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/JuliaCollections/DataStructures.jl/}
}

@article{egg,
author = {Willsey, Max and Nandi, Chandrakana and Wang, Yisu Remy and Flatt, Oliver and Tatlock, Zachary and Panchekha, Pavel},
title = {Egg: Fast and Extensible Equality Saturation},
year = {2021},
issue_date = {January 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {POPL},
url = {https://doi.org/10.1145/3434304},
doi = {10.1145/3434304},
abstract = {An e-graph efficiently represents a congruence relation over many expressions. Although they were originally developed in the late 1970s for use in automated theorem provers, a more recent technique known as equality saturation repurposes e-graphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers. However, e-graphs remain unspecialized for this newer use case. Equality saturation workloads exhibit distinct characteristics and often require ad-hoc e-graph extensions to incorporate transformations beyond purely syntactic rewrites.  This work contributes two techniques that make e-graphs fast and extensible, specializing them to equality saturation. A new amortized invariant restoration technique called rebuilding takes advantage of equality saturation's distinct workload, providing asymptotic speedups over current techniques in practice. A general mechanism called e-class analyses integrates domain-specific analyses into the e-graph, reducing the need for ad hoc manipulation.  We implemented these techniques in a new open-source library called egg. Our case studies on three previously published applications of equality saturation highlight how egg's performance and flexibility enable state-of-the-art results across diverse domains.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {23},
numpages = {29},
keywords = {e-graphs, equality saturation}
}




@article{bezanson2017julia,
author = {Bezanson, Jeff and Edelman, Alan and Karpinski, Stefan and Shah, Viral B.},
title = {Julia: A Fresh Approach to Numerical Computing},
journal = {SIAM Review},
volume = {59},
number = {1},
pages = {65-98},
year = {2017},
doi = {10.1137/141000671},

URL = { 
        https://doi.org/10.1137/141000671
    
},
eprint = { 
        https://doi.org/10.1137/141000671
    
}

}


@article{belyakova2020world,
author = {Belyakova, Julia and Chung, Benjamin and Gelinas, Jack and Nash, Jameson and Tate, Ross and Vitek, Jan},
title = {World Age in {Julia}: Optimizing Method Dispatch in the Presence of Eval},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428275},
doi = {10.1145/3428275},
abstract = {Dynamic programming languages face semantic and performance challenges in the presence of features, such as eval, that can inject new code into a running program. The Julia programming language introduces the novel concept of world age to insulate optimized code from one of the most disruptive side-effects of eval: changes to the definition of an existing function. This paper provides the first formal semantics of world age in a core calculus named juliette, and shows how world age enables compiler optimizations, such as inlining, in the presence of eval. While Julia also provides programmers with the means to bypass world age, we found that this mechanism is not used extensively: a static analysis of over 4,000 registered Julia packages shows that only 4-9% of packages bypass world age. This suggests that Julia's semantics aligns with programmer expectations.},
journal = {Proc. ACM Program. Lang.},
month = nov,
articleno = {207},
numpages = {26},
keywords = {compilation, dynamic languages, eval, method dispatch}
}

@article{zappa2018julia,
author = {Zappa Nardelli, Francesco and Belyakova, Julia and Pelenitsyn, Artem and Chung, Benjamin and Bezanson, Jeff and Vitek, Jan},
title = {{Julia} Subtyping: A Rational Reconstruction},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276483},
doi = {10.1145/3276483},
abstract = {Programming languages that support multiple dispatch rely on an expressive notion of subtyping to specify method applicability. In these languages, type annotations on method declarations are used to select, out of a potentially large set of methods, the one that is most appropriate for a particular tuple of arguments. Julia is a language for scientific computing built around multiple dispatch and an expressive subtyping relation. This paper provides the first formal definition of Julia's subtype relation and motivates its design. We validate our specification empirically with an implementation of our definition that we compare against the existing Julia implementation on a collection of real-world programs. Our subtype implementation differs on 122 subtype tests out of 6,014,476. The first 120 differences are due to a bug in Julia that was fixed once reported; the remaining 2 are under discussion.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {113},
numpages = {27},
keywords = {Subtyping, Multiple Dispatch}
}


@article{panchekha2015automatically,
author = {Panchekha, Pavel and Sanchez-Stern, Alex and Wilcox, James R. and Tatlock, Zachary},
title = {Automatically Improving Accuracy for Floating Point Expressions},
year = {2015},
issue_date = {June 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2813885.2737959},
doi = {10.1145/2813885.2737959},
abstract = { Scientific and engineering applications depend on floating point arithmetic to approximate real arithmetic. This approximation introduces rounding error, which can accumulate to produce unacceptable results. While the numerical methods literature provides techniques to mitigate rounding error, applying these techniques requires manually rearranging expressions and understanding the finer details of floating point arithmetic. We introduce Herbie, a tool which automatically discovers the rewrites experts perform to improve accuracy. Herbie's heuristic search estimates and localizes rounding error using sampled points (rather than static error analysis), applies a database of rules to generate improvements, takes series expansions, and combines improvements for different input regions. We evaluated Herbie on examples from a classic numerical methods textbook, and found that Herbie was able to improve accuracy on each example, some by up to 60 bits, while imposing a median performance overhead of 40%. Colleagues in machine learning have used Herbie to significantly improve the results of a clustering algorithm, and a mathematical library has accepted two patches generated using Herbie. },
journal = {SIGPLAN Not.},
month = jun,
pages = {1–11},
numpages = {11},
keywords = {program rewriting, numerical accuracy, Floating point}
}

@inproceedings{10.1145/2737924.2737959,
author = {Panchekha, Pavel and Sanchez-Stern, Alex and Wilcox, James R. and Tatlock, Zachary},
title = {Automatically Improving Accuracy for Floating Point Expressions},
year = {2015},
isbn = {9781450334686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2737924.2737959},
doi = {10.1145/2737924.2737959},
abstract = { Scientific and engineering applications depend on floating point arithmetic to approximate real arithmetic. This approximation introduces rounding error, which can accumulate to produce unacceptable results. While the numerical methods literature provides techniques to mitigate rounding error, applying these techniques requires manually rearranging expressions and understanding the finer details of floating point arithmetic. We introduce Herbie, a tool which automatically discovers the rewrites experts perform to improve accuracy. Herbie's heuristic search estimates and localizes rounding error using sampled points (rather than static error analysis), applies a database of rules to generate improvements, takes series expansions, and combines improvements for different input regions. We evaluated Herbie on examples from a classic numerical methods textbook, and found that Herbie was able to improve accuracy on each example, some by up to 60 bits, while imposing a median performance overhead of 40%. Colleagues in machine learning have used Herbie to significantly improve the results of a clustering algorithm, and a mathematical library has accepted two patches generated using Herbie. },
booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {1–11},
numpages = {11},
keywords = {numerical accuracy, program rewriting, Floating point},
location = {Portland, OR, USA},
series = {PLDI '15}
}



@article{yang2021equality,
  title={Equality Saturation for Tensor Graph Superoptimization},
  author={Yang, Yichen and Phothilimtha, Phitchaya Mangpo and Wang, Yisu Remy and Willsey, Max and Roy, Sudip and Pienaar, Jacques},
  journal={arXiv preprint arXiv:2101.01332},
  url={https://arxiv.org/pdf/2101.01332.pdf},
  year={2021}
}

@article{nelson1980fast,
author = {Nelson, Greg and Oppen, Derek C.},
title = {Fast Decision Procedures Based on Congruence Closure},
year = {1980},
issue_date = {April 1980},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/322186.322198},
doi = {10.1145/322186.322198},
abstract = {The notion of the congruence closure of a relation on a graph is defined and several algorithms for computing it are surveyed. A simple proof is given that the congruence closure algorithm provides a decision procedure for the quantifier-free theory of equality. A decision procedure is then given for the quantifier-free theory of LISP list structure based on the congruence closure algorithm. Both decision procedures determine the satisfiability of a conjunction of literals of length n in average time O(n log n) using the fastest known congruence closure algorithm. It is also shown that if the axiomatization of the theory of list structure is changed slightly, the problem of determining the satisfiability of a conjunction of literals becomes NP-complete. The decision procedures have been implemented in the authors' simplifier for the Stanford Pascal Verifier.},
journal = {J. ACM},
month = apr,
pages = {356–364},
numpages = {9}
}

@article{philzuck1,
  title={E-graphs in {Julia} {Part I}},
  author={Zucker, Philip},
  year={2020},
  url = {https://www.philipzucker.com/egraph-1/}
}

@article{philzuck2,
  title={E-Graph Pattern Matching {Part II}},
  author={Zucker, Philip},
  year={2020},
  url={https://www.philipzucker.com/egraph-2/}
}
