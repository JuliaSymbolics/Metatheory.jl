var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Metatheory","page":"API Documentation","title":"Metatheory","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory]","category":"page"},{"location":"api/#Metatheory.Options","page":"API Documentation","title":"Metatheory.Options","text":"mutable struct Options\n\nGlobal configurable options for Metatheory.\n\n\n\nFields\n\nverbose::Bool\nPrint or not information such as saturation reports  Default: false\nprintiter::Bool\nPrint iteration numbers in equality saturation  Default: false\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.Classic","page":"API Documentation","title":"Metatheory.Classic","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\n    using Metatheory.EGraphs\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Classic]","category":"page"},{"location":"api/#Metatheory.Classic","page":"API Documentation","title":"Metatheory.Classic","text":"This module contains classical rewriting functions and utilities\n\n\n\nImports\n\nBase\nBase.Meta\nCore\nMatchCore\nMetatheory.Rules\nMetatheory.Util\n\n\n\n\n\n","category":"module"},{"location":"api/#Metatheory.Classic.compile_theory-Tuple{Array{var\"#s13\",1} where var\"#s13\"<:Rule,Module}","page":"API Documentation","title":"Metatheory.Classic.compile_theory","text":"Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Classic.rewrite-Tuple{Any,Union{Function, Array{var\"#s20\",1} where var\"#s20\"<:Rule}}","page":"API Documentation","title":"Metatheory.Classic.rewrite","text":"This function executes a classical rewriting algorithm on a Julia expression ex. Classical rewriting applies rule in order with a fixed point iteration:\n\nThis algorithm heavily relies on RuntimeGeneratedFunctions.jl and the MatchCore pattern matcher. NOTE: this does not involve the use of EGraphs.EGraph or equality saturation (EGraphs.saturate!). When using rewrite, be aware of infinite loops: Since rules are matched in order in every iteration, it is possible that commonly used symbolic rules such as commutativity or associativity of operators may cause this algorithm to have a cycling computation instantly. This algorithm detects cycling computation by keeping an history of hashes, and instantly returns when a cycle is detected.\n\nThis algorithm is suitable for simple, deterministic symbolic rewrites. For more advanced use cases, where it is needed to apply multiple rewrites at the same time, or it is known that rules are causing loops, please use EGraphs.EGraph and equality saturation (EGraphs.saturate!).\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Classic.@compile_theory-Tuple{Any}","page":"API Documentation","title":"Metatheory.Classic.@compile_theory","text":"Compile a theory at runtime to a closure that does the pattern matching job\n\n\n\n\n\n","category":"macro"},{"location":"api/#Metatheory.EGraphs","page":"API Documentation","title":"Metatheory.EGraphs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs]","category":"page"},{"location":"api/#Metatheory.EGraphs.ClassMem","page":"API Documentation","title":"Metatheory.EGraphs.ClassMem","text":"Abstract type representing an EGraph analysis, attaching values from a join semi-lattice domain to an EGraph\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.EGraph","page":"API Documentation","title":"Metatheory.EGraphs.EGraph","text":"mutable struct EGraph\n\nA concrete type representing an [EGraph]. See the egg paper for implementation details\n\n\n\nFields\n\nuf::DataStructures.IntDisjointSets\nstores the equality relations over e-class ids\nclasses::Dict{Int64,Metatheory.EGraphs.EClass}\nmap from eclass id to eclasses\nmemo::Dict{Metatheory.EGraphs.ENode,Int64}\ndirty::Array{Int64,1}\nworklist for ammortized upwards merging\nroot::Int64\nanalyses::Set{Type{var\"#s56\"} where var\"#s56\"<:Metatheory.EGraphs.AbstractAnalysis}\nA vector of analyses associated to the EGraph\nsymcache::Dict{Any,Array{Int64,1}}\na cache mapping function symbols to e-classes that contain e-nodes with that function symbol.\n\nnumclasses::Int64\nnumnodes::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.ExtractionAnalysis","page":"API Documentation","title":"Metatheory.EGraphs.ExtractionAnalysis","text":"An AbstractAnalysis that computes the cost of expression nodes and chooses the node with the smallest cost for each E-Class. This abstract type is parametrised by a function F. This is useful for the analysis storage in EClass\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.SaturationParams","page":"API Documentation","title":"Metatheory.EGraphs.SaturationParams","text":"mutable struct SaturationParams\n\nConfigurable Parameters for the equality saturation process.\n\n\n\nFields\n\ntimeout::Int64\nDefault: 7\nmatchlimit::Int64\nDefault: 5000\neclasslimit::Int64\nDefault: 5000\nstopwhen::Function\nDefault: ()->begin         #= /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation_params.jl:12 =#         false     end\nscheduler::Type{var\"#s56\"} where var\"#s56\"<:Metatheory.EGraphs.Schedulers.AbstractScheduler\nDefault: BackoffScheduler\nschedulerparams::Tuple\nDefault: ()\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.merge!-Tuple{Metatheory.EGraphs.EGraph,Int64,Int64}","page":"API Documentation","title":"Base.merge!","text":"Given an EGraph and two e-class ids, set the two e-classes as equal.\n\n\n\nSignatures\n\nmerge!(g::Metatheory.EGraphs.EGraph, a::Int64, b::Int64) -> Int64\n\n\n\n\nMethods\n\nmerge!(g, a, b)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:194.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.add!-Tuple{Metatheory.EGraphs.EGraph,Metatheory.EGraphs.ENode}","page":"API Documentation","title":"Metatheory.EGraphs.add!","text":"Inserts an e-node in an EGraph\n\n\n\nSignatures\n\nadd!(g::Metatheory.EGraphs.EGraph, n::Metatheory.EGraphs.ENode) -> Metatheory.EGraphs.EClass\n\n\n\n\nMethods\n\nadd!(g, n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:107.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.addexpr!-Tuple{Metatheory.EGraphs.EGraph,Any}","page":"API Documentation","title":"Metatheory.EGraphs.addexpr!","text":"Recursively traverse an type satisfying the TermInterface and insert terms into an EGraph. If e has no children (has an arity of 0) then directly insert the literal into the EGraph.\n\n\n\nSignatures\n\naddexpr!(g::Metatheory.EGraphs.EGraph, se::Any) -> Metatheory.EGraphs.EClass\n\n\n\n\nMethods\n\naddexpr!(g, se)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:152.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.analyze!-Tuple{Metatheory.EGraphs.EGraph,Type{var\"#s19\"} where var\"#s19\"<:Metatheory.EGraphs.AbstractAnalysis,Array{Int64,1}}","page":"API Documentation","title":"Metatheory.EGraphs.analyze!","text":"WARNING. This function is unstable. An EGraph can only contain one analysis of type an.\n\n\n\nSignatures\n\nanalyze!(g::Metatheory.EGraphs.EGraph, an::Type{var\"#s19\"} where var\"#s19\"<:Metatheory.EGraphs.AbstractAnalysis, ids::Array{Int64,1}) -> Bool\n\n\n\n\nMethods\n\nanalyze!(g, an, ids)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.astsize-Tuple{Metatheory.EGraphs.ENode,Metatheory.EGraphs.EGraph,Type{var\"#s56\"} where var\"#s56\"<:Metatheory.EGraphs.AbstractAnalysis}","page":"API Documentation","title":"Metatheory.EGraphs.astsize","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression.\n\n\n\nSignatures\n\nastsize(n::Metatheory.EGraphs.ENode, g::Metatheory.EGraphs.EGraph, an::Type{var\"#s56\"} where var\"#s56\"<:Metatheory.EGraphs.AbstractAnalysis) -> Any\n\n\n\n\nMethods\n\nastsize(n, g, an)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.astsize_inv-Tuple{Metatheory.EGraphs.ENode,Metatheory.EGraphs.EGraph,Type{var\"#s157\"} where var\"#s157\"<:Metatheory.EGraphs.AbstractAnalysis}","page":"API Documentation","title":"Metatheory.EGraphs.astsize_inv","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression\n\n\n\nSignatures\n\nastsize_inv(n::Metatheory.EGraphs.ENode, g::Metatheory.EGraphs.EGraph, an::Type{var\"#s157\"} where var\"#s157\"<:Metatheory.EGraphs.AbstractAnalysis) -> Any\n\n\n\n\nMethods\n\nastsize_inv(n, g, an)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.discard_value-Tuple{NamedTuple}","page":"API Documentation","title":"Metatheory.EGraphs.discard_value","text":"Construct a TimeData from a NamedTuple returned by @timed\n\n\n\nSignatures\n\ndiscard_value(stats::NamedTuple) -> NamedTuple{(:time, :bytes, :gctime),_A} where _A<:Tuple\n\n\n\n\nMethods\n\ndiscard_value(stats)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation_report.jl:19.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.ematchlist-Tuple{Metatheory.EGraphs.EGraph,AbstractArray{Pattern,1},AbstractArray{Int64,1},Base.ImmutableDict{Any,Tuple{Metatheory.EGraphs.EClass,Any}}}","page":"API Documentation","title":"Metatheory.EGraphs.ematchlist","text":"From https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf The iterator ematchlist matches a list of terms t to a list of E-nodes by first finding all substitutions that match the first term to the first E-node, and then extending each such substitution in all possible ways that match the remaining terms to the remaining E-nodes. The base case of this recursion is the empty list, which requires no extension to the substitution; the other case relies on Match to find the substitutions that match the first term to the first E-node.\n\n\n\nSignatures\n\nematchlist(e::Metatheory.EGraphs.EGraph, t::AbstractArray{Pattern,1}, v::AbstractArray{Int64,1}, sub::Base.ImmutableDict{Any,Tuple{Metatheory.EGraphs.EClass,Any}}; buf) -> Array{Base.ImmutableDict{Any,Tuple{Metatheory.EGraphs.EClass,Any}},1}\n\n\n\n\nMethods\n\nematchlist(e, t, v, sub; buf)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/ematch.jl:25.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.eqsat_step!-Tuple{Metatheory.EGraphs.EGraph,Array{var\"#s157\",1} where var\"#s157\"<:Rule,Module,Metatheory.EGraphs.Schedulers.AbstractScheduler,Array{Tuple{Rule,Union{Nothing, Pattern},Base.ImmutableDict{Any,Tuple{Metatheory.EGraphs.EClass,Any}},Int64},1},Metatheory.EGraphs.SaturationParams}","page":"API Documentation","title":"Metatheory.EGraphs.eqsat_step!","text":"Core algorithm of the library: the equality saturation step.\n\n\n\nSignatures\n\neqsat_step!(g::Metatheory.EGraphs.EGraph, theory::Array{var\"#s157\",1} where var\"#s157\"<:Rule, mod::Module, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, match_hist::Array{Tuple{Rule,Union{Nothing, Pattern},Base.ImmutableDict{Any,Tuple{Metatheory.EGraphs.EClass,Any}},Int64},1}, params::Metatheory.EGraphs.SaturationParams) -> Tuple{Metatheory.EGraphs.Report,Metatheory.EGraphs.EGraph}\n\n\n\n\nMethods\n\neqsat_step!(g, theory, mod, scheduler, match_hist, params)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.extract!-Tuple{Metatheory.EGraphs.EGraph,Function}","page":"API Documentation","title":"Metatheory.EGraphs.extract!","text":"Given a cost function, extract the expression with the smallest computed cost from an EGraph\n\n\n\nSignatures\n\nextract!(g::Metatheory.EGraphs.EGraph, costfun::Function; root) -> Any\n\n\n\n\nMethods\n\nextract!(g, costfun; root)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:95.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.extract!-Tuple{Metatheory.EGraphs.EGraph,Type{Metatheory.EGraphs.ExtractionAnalysis{F}} where F}","page":"API Documentation","title":"Metatheory.EGraphs.extract!","text":"Given an ExtractionAnalysis, extract the expression with the smallest computed cost from an EGraph\n\n\n\nSignatures\n\nextract!(g::Metatheory.EGraphs.EGraph, a::Type{Metatheory.EGraphs.ExtractionAnalysis{F}} where F; root) -> Any\n\n\n\n\nMethods\n\nextract!(g, a; root)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:80.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.find-Tuple{Metatheory.EGraphs.EGraph,Int64}","page":"API Documentation","title":"Metatheory.EGraphs.find","text":"Returns the canonical e-class id for a given e-class.\n\n\n\nSignatures\n\nfind(g::Metatheory.EGraphs.EGraph, a::Int64) -> Int64\n\n\n\n\nMethods\n\nfind(g, a)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:83.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.reachable-Tuple{Metatheory.EGraphs.EGraph,Int64}","page":"API Documentation","title":"Metatheory.EGraphs.reachable","text":"Recursive function that traverses an EGraph and returns a vector of all reachable e-classes from a given e-class id.\n\n\n\nSignatures\n\nreachable(g::Metatheory.EGraphs.EGraph, id::Int64) -> Array{Int64,1}\n\n\n\n\nMethods\n\nreachable(g, id)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:343.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.rebuild!-Tuple{Metatheory.EGraphs.EGraph}","page":"API Documentation","title":"Metatheory.EGraphs.rebuild!","text":"This function restores invariants and executes upwards merging in an EGraph. See the egg paper for more details.\n\n\n\nSignatures\n\nrebuild!(egraph::Metatheory.EGraphs.EGraph) -> Union{Nothing, Int64}\n\n\n\n\nMethods\n\nrebuild!(egraph)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:229.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.saturate!-Tuple{Metatheory.EGraphs.EGraph,Array{var\"#s20\",1} where var\"#s20\"<:Rule}","page":"API Documentation","title":"Metatheory.EGraphs.saturate!","text":"Given an EGraph and a collection of rewrite rules, execute the equality saturation algorithm.\n\n\n\nSignatures\n\nsaturate!(g::Metatheory.EGraphs.EGraph, theory::Array{var\"#s20\",1} where var\"#s20\"<:Rule; mod) -> Metatheory.EGraphs.Report\n\n\n\n\nMethods\n\nsaturate!(g, theory; mod)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:62.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs.Schedulers]","category":"page"},{"location":"api/#Metatheory.EGraphs.Schedulers.AbstractScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.AbstractScheduler","text":"abstract type AbstractScheduler\n\nRepresents a rule scheduler for the equality saturation process\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.BackoffScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.BackoffScheduler","text":"struct BackoffScheduler <: Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\nFields\n\ndata::Dict{Rule,Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}\nG::Metatheory.EGraphs.EGraph\ntheory::Array{var\"#s56\",1} where var\"#s56\"<:Rule\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.ScoredScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.ScoredScheduler","text":"struct ScoredScheduler <: Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\nFields\n\ndata::Dict{Rule,Metatheory.EGraphs.Schedulers.ScoredSchedulerEntry}\nG::Metatheory.EGraphs.EGraph\ntheory::Array{var\"#s56\",1} where var\"#s56\"<:Rule\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.SimpleScheduler","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.SimpleScheduler","text":"struct SimpleScheduler <: Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA simple Rewrite Scheduler that applies every rule every time\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Metatheory.EGraphs.Schedulers.cansaturate-Tuple{Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.cansaturate","text":"Should return true if the e-graph can be said to be saturated\n\n\n\nSignatures\n\ncansaturate(s::Metatheory.EGraphs.Schedulers.AbstractScheduler) -> Bool\n\n\n\n\nMethods\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:12.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:48.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/scoredscheduler.jl:77.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers.readstep!-Tuple{Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.readstep!","text":"This function is called before pattern matching on the e-graph\n\n\n\nSignatures\n\nreadstep!(s::Metatheory.EGraphs.Schedulers.AbstractScheduler)\n\n\n\n\nMethods\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:22.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:50.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/scoredscheduler.jl:79.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers.shouldskip-Tuple{Metatheory.EGraphs.Schedulers.AbstractScheduler,Rule}","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.shouldskip","text":"Should return true if the rule r should be skipped\n\n\n\nSignatures\n\nshouldskip(s::Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Rule) -> Bool\n\n\n\n\nMethods\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:17.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:27.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/scoredscheduler.jl:28.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:7.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers.writestep!-Tuple{Metatheory.EGraphs.Schedulers.AbstractScheduler,Rule}","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers.writestep!","text":"This function is called after pattern matching on the e-graph\n\n\n\nSignatures\n\nwritestep!(s::Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Rule) -> Union{Nothing, Int64}\n\n\n\n\nMethods\n\nwritestep!(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:27.\n\nwritestep!(s, rule)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:66.\n\nwritestep!(s, rule)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/scoredscheduler.jl:95.\n\nwritestep!(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util","page":"API Documentation","title":"Metatheory.Util","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Util]","category":"page"},{"location":"api/#Metatheory.Util","page":"API Documentation","title":"Metatheory.Util","text":"Definitions of various utility functions for metaprogramming\n\n\n\nImports\n\nBase\nBase.Meta\nCore\nDocStringExtensions\n\n\n\n\n\n","category":"module"},{"location":"api/#Metatheory.Util.amp-Tuple{Any}","page":"API Documentation","title":"Metatheory.Util.amp","text":"Add a & expression\n\n\n\nSignatures\n\namp(v::Any) -> Expr\n\n\n\n\nMethods\n\namp(v)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:15.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Metatheory.Util.bf_walk!","text":"Breadth First Walk (Tree Prewalk) on expressions mutates expression in-place.\n\n\n\nSignatures\n\nbf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\nbf_walk!(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:52.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Metatheory.Util.bf_walk","text":"Breadth First Walk (Tree Prewalk) on expressions. Does not mutate expressions.\n\n\n\nSignatures\n\nbf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\nbf_walk(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:72.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.binarize!-Tuple{Any,Array{Symbol,1}}","page":"API Documentation","title":"Metatheory.Util.binarize!","text":"HARD FIX of n-arity of operators in Expr trees.\n\n\n\nSignatures\n\nbinarize!(e::Any, ops::Array{Symbol,1}) -> Any\n\n\n\n\nMethods\n\nbinarize!(e, ops)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:12.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.block-Tuple","page":"API Documentation","title":"Metatheory.Util.block","text":"Make a block expression from an array of exprs\n\n\n\nSignatures\n\nblock(vs::Vararg{Any,N} where N) -> Any\n\n\n\n\nMethods\n\nblock(vs)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.cleanast_rec-Tuple{Any}","page":"API Documentation","title":"Metatheory.Util.cleanast_rec","text":"Binarize n-ary operators (+ and *) and call rmlines\n\n\n\nSignatures\n\ncleanast_rec(ex::Any) -> Any\n\n\n\n\nMethods\n\ncleanast_rec(ex)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:58.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Metatheory.Util.df_walk!","text":"Depth First Walk (Tree Postwalk) on expressions, mutates expression in-place.\n\n\n\nSignatures\n\ndf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\ndf_walk!(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Metatheory.Util.df_walk","text":"Depth First Walk (Tree Postwalk) on expressions. Does not mutate expressions.\n\n\n\nSignatures\n\ndf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\ndf_walk(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.dollar-Tuple{Any}","page":"API Documentation","title":"Metatheory.Util.dollar","text":"Add a dollar expression\n\n\n\nSignatures\n\ndollar(v::Any) -> Expr\n\n\n\n\nMethods\n\ndollar(v)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Metatheory.Util.normalize","text":"Iterates a function f on datum until a fixed point is reached where f(x) == x\n\n\n\nSignatures\n\nnormalize(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -> Any\n\n\n\n\nMethods\n\nnormalize(f, datum, fargs; callback)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Metatheory.Util.normalize_nocycle","text":"Like normalize but keeps a vector of hashes to detect cycles, returns the current datum when a cycle is detected\n\n\n\nSignatures\n\nnormalize_nocycle(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -> Any\n\n\n\n\nMethods\n\nnormalize_nocycle(f, datum, fargs; callback)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util.rmlines-Tuple{Expr}","page":"API Documentation","title":"Metatheory.Util.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\nSignatures\n\nrmlines(e::Expr) -> Any\n\n\n\n\nMethods\n\nrmlines(e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:5.\n\n\n\n\n\n","category":"method"},{"location":"theories/#Rules-and-Theories-Syntax","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"","category":"section"},{"location":"theories/#Rule-Syntax-for-Classical-Rewriting","page":"Rules and Theories Syntax","title":"Rule Syntax for Classical Rewriting","text":"","category":"section"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"Kind Supported in Left Hand Side Operator Supported in Right Hand Side\nSymbolic  Rule x  (pattern variables)  :foo (symbol literals)  x::Type (type assertions)  $(2 + 3) (unquoting)  a... (pattern variable destructuring, matches many subterms as a tuple)   Other literals are supported. => x (pattern variables)  :foo(symbol literals)  a... (pattern variable destructuring)   $(2 + 3) (unquoting)  Other literals are supported.\nDynamic Rule Same as above |> Dynamic rules can execute all valid Julia code. The pattern variables  that matched are available (bound) in the r.h.s.. Other global variables  in the execution module are bound. An additional variable _lhs_expr is bound, referring to the left hand side that matched the rule.\nEquational Rule Unsupported == Unsupported","category":"page"},{"location":"theories/#Rule-Syntax-for-EGraphs-Rewriting","page":"Rules and Theories Syntax","title":"Rule Syntax for EGraphs Rewriting","text":"","category":"section"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"Kind Supported in  Left Hand Side Operator Supported in Right Hand Side\nSymbolic  Rule x  (pattern variables)  :foo (symbol literals)  x::Type (type assertions)  $(2 + 3) (unquoting)   Other literals are supported. Pattern variable destructuring is not supported. => x (pattern variables)  :foo(symbol literals)   $(2 + 3) (unquoting)  Other literals are supported.\nDynamic Rule Same as above |> Dynamic rules execute valid Julia code. The pattern variables  that matched are available (bound) in the r.h.s.. Other global variables  in the execution module are bound. An additional variable _lhs_expr is bound,  referring to the left hand side that matched the rule.  NOTE: additionally, the _egraph variable is bound,  referring to the current EGraph on which rewriting is happening.\nEquational Rule Same as Symbolic Rules. == Same as left hand side of symbolic rules.","category":"page"},{"location":"theories/#Theories-are-Collections-and-Composable","page":"Rules and Theories Syntax","title":"Theories are Collections and Composable","text":"","category":"section"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"Theories are just collections, precisely vectors of the Rule object, and can be composed as regular Julia collections. The most useful way of composing theories is unioning them with the 'âˆª' operator. You are not limited to composing theories, you can manipulate and create them at both runtime and compile time as regular vectors.","category":"page"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"comm_group = @theory begin\n    a + 0 => a\n    a + b => b + a\n    a + inv(a) => 0 # inverse\n    a + (b + c) => (a + b) + c\nend\ndistrib = @theory begin\n    a * (b + c) => (a * b) + (a * c)\nend\nt = comm_monoid âˆª comm_group âˆª distrib","category":"page"},{"location":"theories/#Type-Assertions-and-Dynamic-Rules","page":"Rules and Theories Syntax","title":"Type Assertions and Dynamic Rules","text":"","category":"section"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"You can use type assertions in the left hand of rules to match and access literal values both when using classic rewriting and EGraph based rewriting.","category":"page"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"You can also use dynamic rules, defined with the |> operator, to dynamically compute values in the right hand of expressions. Dynamic rules, are similar to anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic |> rule is evaluated during rewriting: the values that produced a match are bound to the pattern variables.","category":"page"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"fold_mul = @theory begin\n    a::Number * b::Number |> a*b\nend\nt = comm_monoid âˆª fold_mul\n@areequal t (3*4) 12","category":"page"},{"location":"theories/#Escaping","page":"Rules and Theories Syntax","title":"Escaping","text":"","category":"section"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"You can escape values in the left hand side of rules using $ just as you would do with the regular quoting/unquoting mechanism.","category":"page"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"example = @theory begin\n    a + $(3+2) |> :something\nend","category":"page"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"Becomes","category":"page"},{"location":"theories/","page":"Rules and Theories Syntax","title":"Rules and Theories Syntax","text":"1-element Vector{Rule}:\n Rule(:(a + 5 |> :something))","category":"page"},{"location":"analysis/#EGraph-Analyses-and-Extraction","page":"EGraph Analyses and Extraction","title":"EGraph Analyses and Extraction","text":"","category":"section"},{"location":"analysis/#Extracting-from-an-E-Graph","page":"EGraph Analyses and Extraction","title":"Extracting from an E-Graph","text":"","category":"section"},{"location":"analysis/","page":"EGraph Analyses and Extraction","title":"EGraph Analyses and Extraction","text":"Extraction can be formulated as an EGraph analysis, or after saturation. A cost function can be provided. Metatheory.jl already provides some simple cost functions, such as astsize, which expresses preference for the smallest expressions.","category":"page"},{"location":"analysis/","page":"EGraph Analyses and Extraction","title":"EGraph Analyses and Extraction","text":"G = EGraph(:((log(e) * log(e)) * (log(a^3 * a^2))))\nsaturate!(G, t)\nextractor = addanalysis!(G, ExtractionAnalysis, astsize)\nex = extract!(G, extractor)\nex == :(log(a) * 5)","category":"page"},{"location":"analysis/#Complex-Example","page":"EGraph Analyses and Extraction","title":"Complex Example","text":"","category":"section"},{"location":"analysis/","page":"EGraph Analyses and Extraction","title":"EGraph Analyses and Extraction","text":"Let's see a more complex example: extracting the smallest equivalent expression, from a trivial mathematics theory","category":"page"},{"location":"analysis/","page":"EGraph Analyses and Extraction","title":"EGraph Analyses and Extraction","text":"distrib = @theory begin\n\ta * (b + c) => (a * b) + (a * c)\n\t(a * b) + (a * c) => a * (b + c)\nend\npowers = @theory begin\n\ta * a => a^2\n\ta => a^1\n\ta^n * a^m => a^(n+m)\nend\nlogids = @theory begin\n\tlog(a^n) => n * log(a)\n\tlog(x * y) => log(x) + log(y)\n\tlog(1) => 0\n\tlog(:e) => 1\n\t:e^(log(x)) => x\nend\nfold_add = @theory begin\n\ta::Number + b::Number |> a + b\nend\nt = comm_monoid âˆª comm_group âˆª distrib âˆª powers âˆª logids âˆª fold_mul âˆª fold_add","category":"page"},{"location":"egraphs/#EGraphs-and-Equality-Saturation","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"An EGraph is an efficient data structure for representing congruence relations. EGraphs are data structures originating from theorem provers. Several projects have very recently  repurposed EGraphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers using a technique known as equality saturation. Metatheory.jl provides a general purpose, customizable implementation of EGraphs and equality saturation, inspired from the egg library for Rust. You can read more about the design of the EGraph data structure and equality saturation algorithm in the egg paper.","category":"page"},{"location":"egraphs/#What-can-I-do-with-EGraphs-in-Metatheory.jl?","page":"EGraphs and Equality Saturation","title":"What can I do with EGraphs in Metatheory.jl?","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Most importantly, the EGraph backend for Metatheory.jl allows you to create an EGraph from a starting expression, to add more expressions to the EGraph with addexpr!, and then to effectively fill the EGraph with all possible equivalent expressions resulting from applying rewrite rules from a theory, by using the saturate! function. You can then easily extract expressions with a cost function and an ExtractionAnalysis.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"A killer feature of egg and Metatheory.jl are EGraph Analyses. They allow you to annotate expressions and equivalence classes in an EGraph with values from a semilattice domain, and then to:","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"Extract expressions from an EGraph basing from analysis data.\nHave conditional rules that are executed if some criteria is met on analysis data\nHave dynamic rules that compute the right hand side based on analysis data.","category":"page"},{"location":"egraphs/#Theories-and-Algebraic-Structures","page":"EGraphs and Equality Saturation","title":"Theories and Algebraic Structures","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The e-graphs backend can directly handle associativity, commutativity and distributivity, rules that are otherwise known of causing loops in symbolic computations.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"comm_monoid = @theory begin\n    a * b => b * a\n    a * 1 => a\n    a * (b * c) => (a * b) * c\nend","category":"page"},{"location":"egraphs/#The-Metatheory-Library","page":"EGraphs and Equality Saturation","title":"The Metatheory Library","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"The Metatheory.Library module contains utility functions and macros for creating rules and theories from commonly used algebraic structures and properties.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"using Metatheory.Library\n\ncomm_monoid = commutative_monoid(:(*), 1)\n# alternatively\ncomm_monoid = @commutative_monoid (*) 1","category":"page"},{"location":"egraphs/#Equality-Saturation","page":"EGraphs and Equality Saturation","title":"Equality Saturation","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"We can programmatically build and saturate an EGraph. The function saturate! takes an EGraph and a theory, and executes equality saturation. Returns a report of the equality saturation process. saturate! is configurable, customizable parameters include a timeout on the number of iterations, a eclasslimit on the number of e-classes in the EGraph, a stopwhen functions that stops saturation when it evaluates to true.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"G = EGraph(:((a * b) * (1 * (b + c))));\nreport = saturate!(G, t);\n# access the saturated EGraph\nreport.egraph\n\n# show some fancy stats\nprintln(report);\n","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"With the EGraph equality saturation backend, Metatheory.jl can prove simple equalities very efficiently. The @areequal macro takes a theory and some expressions and returns true iff the expressions are equal according to the theory. The following example returns true.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"@areequal t (x+y)*(a+b) ((a*(x+y))+b*(x+y)) ((x*(a+b))+y*(a+b))","category":"page"},{"location":"egraphs/#Configurable-Parameters","page":"EGraphs and Equality Saturation","title":"Configurable Parameters","text":"","category":"section"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"saturate! can accept an additional parameter of type SaturationParams to configure the equality saturation algorithm. The documentation for the configurable parameters is available in the SaturationParams API docstring.","category":"page"},{"location":"egraphs/","page":"EGraphs and Equality Saturation","title":"EGraphs and Equality Saturation","text":"# create the saturation params\nparams = SaturationParams(timeout=10, eclasslimit=4000)\nsaturate!(egraph, theory, params)","category":"page"},{"location":"classic/#Classical-Rewriting","page":"Classical Rewriting","title":"Classical Rewriting","text":"","category":"section"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\n    using Metatheory.EGraphs\nend","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"There are some use cases where EGraphs and equality saturation are not required. The classical rewriting backend is suited for simple tasks when computing the whole equivalence class is overkill.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"The classical rewriting backend can be accessed with the rewrite function, which uses a recursive fixed point iteration algorithm to rewrite a source expression. The expression can be traversed with a depth first (inner left expression) evaluation order, or with a breadth first (outer left expression) evaluation order. You can configure the evaluation order by passing the keyword argument order=:inner (default) or order=:outer to the rewrite function.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Note: With the classical rewrite algorithm, rules are matched in order and applied deterministically: every iteration, only the first rule that matches is applied. This means that when using the classical rewriting backend, the ordering of rules in a theory matters!. If some rules produce a loop, which is common for regular algebraic rules such as commutativity, distributivity and associativity, the other following rules in the theory will never be applied.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"The classical rewrite algorithm is suitable for:","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Simple Pattern Matching Tasks\nInterpretation of Code (e.g. interpretation of an eDSL)\nNon-Optimizing Compiler Steps and Transformations (e.g. Your eDSL â€“> Julia)\nSimple Deterministic Manipulation Tasks (e.g. cleaning expressions)","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"For algebraic, mathematics oriented rewriting, please use the EGraph backend.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Rewriting loops are detected by keeping an history of hashes of the rewritten expression. When a loop is detected, rewriting stops immediately and returns the current expression.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Metatheory.jl is meant for composability: you can always compose and interleave rewriting steps that use the classical rewriting backend or the more advanced EGraph backend.","category":"page"},{"location":"classic/#Example","page":"Classical Rewriting","title":"Example","text":"","category":"section"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Let's simplify an expression in the comm_monoid theory by using the EGraph backend. After simplification, we may want to move all the Ïƒ symbols to the right of multiplications, we can do this simple task with a classical rewriting step, by using the rewrite function.","category":"page"},{"location":"classic/#Step-1:-Simplification-with-EGraphs","page":"Classical Rewriting","title":"Step 1: Simplification with EGraphs","text":"","category":"section"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"using Metatheory\nusing Metatheory.EGraphs\nusing Metatheory.Library\n\ncomm_monoid = commutative_monoid(:(*), 1);\nstart_expr = :( (a * (1 * (2Ïƒ)) * (b * Ïƒ + (c * 1)) ) );\ng = EGraph(start_expr);\nextractor = addanalysis!(g, ExtractionAnalysis, astsize);\nsaturate!(g, comm_monoid);\nsimplified = extract!(g, extractor)\n\n# output\n:(a * (Ïƒ * 2) * (Ïƒ * b + c))\n","category":"page"},{"location":"classic/#Step-2:-Moving-Ïƒ-to-the-right","page":"Classical Rewriting","title":"Step 2: Moving Ïƒ to the right","text":"","category":"section"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"moveright = @theory begin\n\t:Ïƒ * a \t\t\t\t=> a*:Ïƒ\n\t(a * :Ïƒ) * b \t=> (a * b) * :Ïƒ\n\t(:Ïƒ * a) * b \t=> (a * b) * :Ïƒ\nend;\n\nsimplified = rewrite(simplified, moveright);\n\n# output\n:((a * (2 * :Ïƒ)) * (b * :Ïƒ + c))","category":"page"},{"location":"classic/#Assignment-to-variables-during-rewriting.","page":"Classical Rewriting","title":"Assignment to variables during rewriting.","text":"","category":"section"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Using the classical rewriting backend, you may want to assign a value to an externally defined variable. Because of the nature of modules and the RuntimeGeneratedFunction compilation pipeline, it is not possible to assign values to variables in other modules. You can achieve such behaviour by using Julia References (docs), which behave similarly to pointers in other languages such as C or OCaml.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Note: due to nondeterminism, it is unrecommended to assign values to Refs when using the EGraph backend!","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"safe_var = 0\nref_var = Ref{Real}(0)\n\nreft = @theory begin\n\t:safe |> (safe_var = Ï€)\n\t:ref |> (ref_var[] = Ï€)\nend\n\nrewrite(:(safe), reft; order=:inner, m=@__MODULE__)\nrewrite(:(ref), reft; order=:inner, m=@__MODULE__)\n\nsafe_var == 0\nref_var[] == Ï€","category":"page"},{"location":"classic/#A-Tiny-Imperative-Programming-Language-Interpreter","page":"Classical Rewriting","title":"A Tiny Imperative Programming Language Interpreter","text":"","category":"section"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"Here is an example showing interpretation of a very tiny, turing complete subset of the Julia programming language. To achieve turing completeness in an imperative paradigm language, just integer+boolean arithmetic and if and while statements are needed. Since a recursive algorithm is sufficient for interpreting those expressions, this example does not use the e-graphs backend! Note how we are representing semantics for a different programming language by reusing the Julia AST data structure, and therefore efficiently reusing the Julia parser for our new toy language.","category":"page"},{"location":"classic/","page":"Classical Rewriting","title":"Classical Rewriting","text":"See this test file.","category":"page"},{"location":"#Metatheory.jl","page":"Metatheory.jl","title":"Metatheory.jl","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"<p align=\"center\">\n<img width=\"400px\" src=\"https://raw.githubusercontent.com/0x0f0f0f/Metatheory.jl/master/docs/src/assets/dragon.jpg\"/>\n</p>","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Metatheory.jl is a general purpose metaprogramming and algebraic computation library for the Julia programming language, designed to take advantage of the powerful reflection capabilities to bridge the gap between symbolic mathematics, abstract interpretation, equational reasoning, optimization, composable compiler transforms, and advanced homoiconic pattern matching features.","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Read the preprint on arXiv.","category":"page"},{"location":"#Installation","page":"Metatheory.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"You can install the stable version:","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"julia> using Pkg; Pkg.add(\"Metatheory\")","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Or you can install the developer version (recommended by now for latest bugfixes)","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/0x0f0f0f/Metatheory.jl\")","category":"page"},{"location":"#Usage","page":"Metatheory.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Since Metatheory.jl relies on RuntimeGeneratedFunctions.jl, you have to call @metatheory_init in the module where you are going to use Metatheory.","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"using Metatheory\nusing Metatheory.EGraphs\n\n@metatheory_init","category":"page"},{"location":"#Citing","page":"Metatheory.jl","title":"Citing","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"If you use Metatheory.jl in your research, please cite our works.","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"@misc{cheli2021metatheoryjl,\n      title={Metatheory.jl: Fast and Elegant Algebraic Computation in Julia with Extensible Equality Saturation},\n      author={Alessandro Cheli},\n      year={2021},\n      eprint={2102.07888},\n      archivePrefix={arXiv},\n      primaryClass={cs.PL}\n}","category":"page"}]
}
