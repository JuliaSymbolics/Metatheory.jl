<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rules and Theories Syntax · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl</a></li><li class="is-active"><a class="tocitem" href>Rules and Theories Syntax</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Rule-Syntax-for-Classical-Rewriting"><span>Rule Syntax for Classical Rewriting</span></a></li><li class="toplevel"><a class="tocitem" href="#Rule-Syntax-for-EGraphs-Rewriting"><span>Rule Syntax for EGraphs Rewriting</span></a></li><li><a class="tocitem" href="#Theories-are-Collections-and-Composable"><span>Theories are Collections and Composable</span></a></li><li><a class="tocitem" href="#Type-Assertions-and-Dynamic-Rules"><span>Type Assertions and Dynamic Rules</span></a></li><li><a class="tocitem" href="#Escaping"><span>Escaping</span></a></li></ul></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../analysis/">EGraph Analyses and Extraction</a></li><li><a class="tocitem" href="../classic/">Classical Rewriting</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Rules and Theories Syntax</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rules and Theories Syntax</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/master/docs/src/theories.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Rules-and-Theories-Syntax"><a class="docs-heading-anchor" href="#Rules-and-Theories-Syntax">Rules and Theories Syntax</a><a id="Rules-and-Theories-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Rules-and-Theories-Syntax" title="Permalink"></a></h1><h1 id="Rule-Syntax-for-Classical-Rewriting"><a class="docs-heading-anchor" href="#Rule-Syntax-for-Classical-Rewriting">Rule Syntax for Classical Rewriting</a><a id="Rule-Syntax-for-Classical-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Syntax-for-Classical-Rewriting" title="Permalink"></a></h1><table><tr><th style="text-align: right">Kind</th><th style="text-align: right">Supported in Left Hand Side</th><th style="text-align: right">Operator</th><th style="text-align: right">Supported in Right Hand Side</th></tr><tr><td style="text-align: right">Symbolic  Rule</td><td style="text-align: right"><code>x</code>  (pattern variables) <span>$\\$</span> <code>:foo</code> (symbol literals) <span>$\\$</span> <code>x::Type</code> (type assertions) <span>$\\$</span> <code>$(2 + 3)</code> (unquoting) <span>$\\$</span> <code>a...</code> (pattern variable destructuring, matches many subterms as a tuple) <span>$\\$</span>  Other literals are supported.</td><td style="text-align: right"><code>=&gt;</code></td><td style="text-align: right"><code>x</code> (pattern variables) <span>$\\$</span> <code>:foo</code>(symbol literals) <span>$\\$</span> <code>a...</code> (pattern variable destructuring) <span>$\\$</span>  <code>$(2 + 3)</code> (unquoting) <span>$\\$</span> Other literals are supported.</td></tr><tr><td style="text-align: right">Dynamic Rule</td><td style="text-align: right">Same as above</td><td style="text-align: right"><code>|&gt;</code></td><td style="text-align: right">Dynamic rules can execute all valid Julia code. The pattern variables  that matched are available (bound) in the r.h.s.. Other global variables  in the execution module are bound. An additional variable <code>_lhs_expr</code> is bound, referring to the left hand side that matched the rule.</td></tr><tr><td style="text-align: right">Equational Rule</td><td style="text-align: right">Unsupported</td><td style="text-align: right"><code>==</code></td><td style="text-align: right">Unsupported</td></tr></table><h1 id="Rule-Syntax-for-EGraphs-Rewriting"><a class="docs-heading-anchor" href="#Rule-Syntax-for-EGraphs-Rewriting">Rule Syntax for EGraphs Rewriting</a><a id="Rule-Syntax-for-EGraphs-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Syntax-for-EGraphs-Rewriting" title="Permalink"></a></h1><table><tr><th style="text-align: right">Kind</th><th style="text-align: right">Supported in  Left Hand Side</th><th style="text-align: right">Operator</th><th style="text-align: right">Supported in Right Hand Side</th></tr><tr><td style="text-align: right">Symbolic  Rule</td><td style="text-align: right"><code>x</code>  (pattern variables) <span>$\\$</span> <code>:foo</code> (symbol literals) <span>$\\$</span> <code>x::Type</code> (type assertions) <span>$\\$</span> <code>$(2 + 3)</code> (unquoting) <span>$\\$</span>  Other literals are supported. <strong>Pattern variable destructuring is not supported</strong>.</td><td style="text-align: right"><code>=&gt;</code></td><td style="text-align: right"><code>x</code> (pattern variables) <span>$\\$</span> <code>:foo</code>(symbol literals) <span>$\\$</span>  <code>$(2 + 3)</code> (unquoting) <span>$\\$</span> Other literals are supported.</td></tr><tr><td style="text-align: right">Dynamic Rule</td><td style="text-align: right">Same as above</td><td style="text-align: right"><code>|&gt;</code></td><td style="text-align: right">Dynamic rules execute valid Julia code. The pattern variables  that matched are available (bound) in the r.h.s.. Other global variables  in the execution module are bound. An additional variable <code>_lhs_expr</code> is bound,  referring to the left hand side that matched the rule.  <strong>NOTE</strong>: additionally, the <code>_egraph</code> variable is bound,  referring to the current <code>EGraph</code> on which rewriting is happening.</td></tr><tr><td style="text-align: right">Equational Rule</td><td style="text-align: right">Same as Symbolic Rules.</td><td style="text-align: right"><code>==</code></td><td style="text-align: right">Same as left hand side of symbolic rules.</td></tr></table><h2 id="Theories-are-Collections-and-Composable"><a class="docs-heading-anchor" href="#Theories-are-Collections-and-Composable">Theories are Collections and Composable</a><a id="Theories-are-Collections-and-Composable-1"></a><a class="docs-heading-anchor-permalink" href="#Theories-are-Collections-and-Composable" title="Permalink"></a></h2><p>Theories are just collections, precisely <em>vectors of the <code>Rule</code> object</em>, and can be composed as regular Julia collections. The most useful way of composing theories is unioning them with the &#39;∪&#39; operator. You are not limited to composing theories, you can manipulate and create them at both runtime and compile time as regular vectors.</p><pre><code class="language-julia">comm_group = @theory begin
    a + 0 =&gt; a
    a + b =&gt; b + a
    a + inv(a) =&gt; 0 # inverse
    a + (b + c) =&gt; (a + b) + c
end
distrib = @theory begin
    a * (b + c) =&gt; (a * b) + (a * c)
end
t = comm_monoid ∪ comm_group ∪ distrib</code></pre><h2 id="Type-Assertions-and-Dynamic-Rules"><a class="docs-heading-anchor" href="#Type-Assertions-and-Dynamic-Rules">Type Assertions and Dynamic Rules</a><a id="Type-Assertions-and-Dynamic-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Assertions-and-Dynamic-Rules" title="Permalink"></a></h2><p>You can use type assertions in the left hand of rules to match and access literal values both when using classic rewriting and EGraph based rewriting.</p><p>You can also use <strong>dynamic rules</strong>, defined with the <code>|&gt;</code> operator, to dynamically compute values in the right hand of expressions. Dynamic rules, are similar to anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>|&gt;</code> rule is evaluated during rewriting: the values that produced a match are bound to the pattern variables.</p><pre><code class="language-julia">fold_mul = @theory begin
    a::Number * b::Number |&gt; a*b
end
t = comm_monoid ∪ fold_mul
@areequal t (3*4) 12</code></pre><h2 id="Escaping"><a class="docs-heading-anchor" href="#Escaping">Escaping</a><a id="Escaping-1"></a><a class="docs-heading-anchor-permalink" href="#Escaping" title="Permalink"></a></h2><p>You can escape values in the left hand side of rules using <code>$</code> just as you would do with the regular <a href=".">quoting/unquoting</a> mechanism.</p><pre><code class="language-julia">example = @theory begin
    a + $(3+2) |&gt; :something
end</code></pre><p>Becomes</p><pre><code class="language-none">1-element Vector{Rule}:
 Rule(:(a + 5 |&gt; :something))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Metatheory.jl</a><a class="docs-footer-nextpage" href="../egraphs/">EGraphs and Equality Saturation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 16 March 2021 20:53">Tuesday 16 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
