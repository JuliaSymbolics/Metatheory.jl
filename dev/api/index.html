<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl 2.0</a></li><li><a class="tocitem" href="../rewrite/">Classical Term Rewriting</a></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../visualizing/">Visualizing E-Graphs</a></li><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Patterns"><span>Patterns</span></a></li><li><a class="tocitem" href="#Rules"><span>Rules</span></a></li><li><a class="tocitem" href="#Rules-2"><span>Rules</span></a></li><li><a class="tocitem" href="#Rewriters"><span>Rewriters</span></a></li><li><a class="tocitem" href="#EGraphs"><span>EGraphs</span></a></li><li><a class="tocitem" href="#EGraph-Schedulers"><span>EGraph Schedulers</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/custom_types/">Interfacing with Metatheory.jl</a></li><li><a class="tocitem" href="../tutorials/fibonacci/">Benchmarking Fibonacci. E-Graphs memoize computation.</a></li><li><a class="tocitem" href="../tutorials/mu/">The MU Puzzle</a></li><li><a class="tocitem" href="../tutorials/while_interpreter/">Write a very tiny Turing Complete language in Julia.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.rewrite_rhs-Tuple{Expr}" href="#Metatheory.Syntax.rewrite_rhs-Tuple{Expr}"><code>Metatheory.Syntax.rewrite_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rewrite_rhs(expr::Expr)</code></pre><p>Rewrite the <code>expr</code> by dealing with <code>:where</code> if necessary. The <code>:where</code> is rewritten from, for example, <code>~x where f(~x)</code> to <code>f(~x) ? ~x : nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Syntax.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.rmlines-Tuple{Expr}" href="#Metatheory.Syntax.rmlines-Tuple{Expr}"><code>Metatheory.Syntax.rmlines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove LineNumberNode from quoted blocks of code</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Syntax.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@capture-Tuple" href="#Metatheory.Syntax.@capture-Tuple"><code>Metatheory.Syntax.@capture</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@capture ex pattern</code></pre><p>Uses a <code>Rule</code> object to capture an expression if it matches the <code>pattern</code>. Returns <code>true</code> and injects slot variable match results into the calling scope when the <code>pattern</code> matches, otherwise returns false. The rule language for specifying the <code>pattern</code> is the same in @capture as it is in <code>@rule</code>. Contextual matching is not yet supported</p><pre><code class="language-julia">julia&gt; @syms a; ex = a^a;
julia&gt; if @capture ex (~x)^(~x)
           @show x
       elseif @capture ex 2(~y)
           @show y
       end;
x = a</code></pre><p>See also: <a href="#Metatheory.Syntax.@rule-Tuple"><code>@rule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Syntax.jl#L405-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@rule-Tuple" href="#Metatheory.Syntax.@rule-Tuple"><code>Metatheory.Syntax.@rule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@rule [SLOTS...] LHS operator RHS</code></pre><p>Creates an <code>AbstractRule</code> object. A rule object is callable, and takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns <code>nothing</code> otherwise. The rule language is described below.</p><p>LHS can be any possibly nested function call expression where any of the arugments can optionally be a Slot (<code>~x</code>) or a Segment (<code>~x...</code>) (described below).</p><p>SLOTS is an optional list of symbols to be interpeted as slots or segments directly (without using <code>~</code>).  To declare slots for several rules at once, see the <code>@slots</code> macro.</p><p>If an expression matches LHS entirely, then it is rewritten to the pattern in the RHS , whose local scope includes the slot matches as variables. Segment (<code>~x</code>) and slot variables (<code>~~x</code>) on the RHS will substitute the result of the matches found for these variables in the LHS.</p><p><strong>Rule operators</strong>:</p><ul><li><code>LHS =&gt; RHS</code>: create a <code>DynamicRule</code>. The RHS is <em>evaluated</em> on rewrite.</li><li><code>LHS --&gt; RHS</code>: create a <code>RewriteRule</code>. The RHS is <strong>not</strong> evaluated but <em>symbolically substituted</em> on rewrite.</li><li><code>LHS == RHS</code>: create a <code>EqualityRule</code>. In e-graph rewriting, this rule behaves like <code>RewriteRule</code> but can go in both directions. Doesn&#39;t work in classical rewriting</li><li><code>LHS ≠ RHS</code>: create a <code>UnequalRule</code>. Can only be used in e-graphs, and is used to eagerly stop the process of rewriting if LHS is found to be equal to RHS.</li></ul><p><strong>Slot</strong>:</p><p>A Slot variable is written as <code>~x</code> and matches a single expression. <code>x</code> is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by <code>isequal</code>).</p><p><em>Example:</em></p><p>Simple rule to turn any <code>sin</code> into <code>cos</code>:</p><pre><code class="language-julia">julia&gt; r = @rule sin(~x) --&gt; cos(~x)
sin(~x) --&gt; cos(~x)

julia&gt; r(:(sin(1+a)))
:(cos((1 + a)))</code></pre><p>A rule with 2 segment variables</p><pre><code class="language-julia">julia&gt; r = @rule sin(~x + ~y) --&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y)
sin(~x + ~y) --&gt; sin(~x) * cos(~y) + cos(~x) * sin(~y)

julia&gt; r(:(sin(a + b)))
:(cos(a)*sin(b) + sin(a)*cos(b))</code></pre><p>A rule that matches two of the same expressions:</p><pre><code class="language-julia">julia&gt; r = @rule sin(~x)^2 + cos(~x)^2 --&gt; 1
sin(~x) ^ 2 + cos(~x) ^ 2 --&gt; 1

julia&gt; r(:(sin(2a)^2 + cos(2a)^2))
1

julia&gt; r(:(sin(2a)^2 + cos(a)^2))
# nothing</code></pre><p>A rule without <code>~</code></p><pre><code class="language-julia">julia&gt; r = @slots x y z @rule x(y + z) --&gt; x*y + x*z
x(y + z) --&gt; x*y + x*z</code></pre><p><strong>Segment</strong>: A Segment variable matches zero or more expressions in the function call. Segments may be written by splatting slot variables (<code>~x...</code>).</p><p><em>Example:</em></p><pre><code class="language-julia">julia&gt; r = @rule f(~xs...) --&gt; g(~xs...);
julia&gt; r(:(f(1, 2, 3)))
:(g(1,2,3))</code></pre><p><strong>Predicates</strong>:</p><p>There are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both <code>~x</code> and <code>~~x</code> by using the <code>~x::f</code> or <code>~~x::f</code>. Here <code>f</code> can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.</p><p>The predicate should return <code>true</code> if the current match is acceptable, and <code>false</code> otherwise.</p><pre><code class="language-julia">julia&gt; two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) &lt; 10^-9
two_πs (generic function with 1 method)

julia&gt; two_πs(x) = false
two_πs (generic function with 2 methods)

julia&gt; r = @rule sin(~~x + ~y::two_πs + ~~z) =&gt; :(sin($(Expr(:call, :+, ~~x..., ~~z...))))
sin(~(~x) + ~(y::two_πs) + ~(~z)) --&gt; sin(+(~(~x)..., ~(~z)...))

julia&gt; r(:(sin(a+$(3π))))

julia&gt; r(:(sin(a+$(6π))))
:(sin(+a))

julia&gt; r(sin(a+6π+c))
:(sin(a + c))</code></pre><p>Predicate function gets an array of values if attached to a segment variable (<code>~x...</code>).</p><p>For the predicate over the whole rule, use <code>@rule &lt;LHS&gt; =&gt; &lt;RHS&gt; where &lt;predicate&gt;</code>:</p><pre><code class="language-none">julia&gt; predicate(x) = x === a;

julia&gt; r = @rule ~x =&gt; ~x where f(~x);

julia&gt; r(a)
a

julia&gt; r(b) === nothing
true</code></pre><p>Note that this is syntactic sugar and that it is the same as <code>@rule ~x =&gt; f(~x) ? ~x : nothing</code>.</p><p><strong>Compatibility</strong>: Segment variables may still be written as (<code>~~x</code>), and slot (<code>~x</code>) and segment (<code>~x...</code> or <code>~~x</code>) syntaxes on the RHS will still substitute the result of the matches. See also: <a href="#Metatheory.Syntax.@capture-Tuple"><code>@capture</code></a>, <a href="#Metatheory.Syntax.@slots-Tuple"><code>@slots</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Syntax.jl#L195-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@slots-Tuple" href="#Metatheory.Syntax.@slots-Tuple"><code>Metatheory.Syntax.@slots</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@slots [SLOTS...] ex</code></pre><p>Declare SLOTS as slot variables for all <code>@rule</code> or <code>@capture</code> invocations in the expression <code>ex</code>. <em>Example:</em></p><pre><code class="language-julia">julia&gt; @slots x y z a b c Chain([
    (@rule x^2 + 2x*y + y^2 =&gt; (x + y)^2),
    (@rule x^a * y^b =&gt; (x*y)^a * y^(b-a)),
    (@rule +(x...) =&gt; sum(x)),
])</code></pre><p>See also: <a href="#Metatheory.Syntax.@rule-Tuple"><code>@rule</code></a>, <a href="#Metatheory.Syntax.@capture-Tuple"><code>@capture</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Syntax.jl#L173-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Syntax.@theory-Tuple" href="#Metatheory.Syntax.@theory-Tuple"><code>Metatheory.Syntax.@theory</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@theory [SLOTS...] begin (LHS operator RHS)... end</code></pre><p>Syntax sugar to define a vector of rules in a nice and readable way. Can use <code>@slots</code> or have the slots  as the first arguments:</p><pre><code class="language-none">julia&gt; t = @theory x y z begin 
    x * (y + z) --&gt; (x * y) + (x * z)
    x + y       ==  (y + x)
    #...
end;</code></pre><p>Is the same thing as writing</p><pre><code class="language-none">julia&gt; v = [
    @rule x y z  x * (y + z) --&gt; (x * y) + (x * z)
    @rule x y x + y == (y + x)
    #...
];</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Syntax.jl#L362-L385">source</a></section></article><hr/><h2 id="Patterns"><a class="docs-heading-anchor" href="#Patterns">Patterns</a><a id="Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Patterns" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.AbstractPat" href="#Metatheory.Patterns.AbstractPat"><code>Metatheory.Patterns.AbstractPat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing a pattern used in all the various pattern matching backends. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Patterns.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.PatSegment" href="#Metatheory.Patterns.PatSegment"><code>Metatheory.Patterns.PatSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p>If you want to match a variable number of subexpressions at once, you will need a <strong>segment pattern</strong>.  A segment pattern represents a vector of subexpressions matched.  You can attach a predicate <code>g</code> to a segment variable. In the case of segment variables <code>g</code> gets a vector of 0 or more  expressions and must return a boolean value. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Patterns.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.PatTerm" href="#Metatheory.Patterns.PatTerm"><code>Metatheory.Patterns.PatTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Term patterns will match on terms of the same <code>arity</code> and with the same  function symbol <code>operation</code> and expression head <code>exprhead</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Patterns.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.PatVar" href="#Metatheory.Patterns.PatVar"><code>Metatheory.Patterns.PatVar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PatVar{P}(name, debrujin_index, predicate::P)</code></pre><p>Pattern variables will first match on one subterm and instantiate the substitution to that subterm.</p><p>Matcher pattern may contain pattern variables with attached predicates, where <code>predicate</code> is a function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if <code>f</code> returns true.</p><p><code>predicate</code> can also be a <code>Type{&lt;:t}</code>, this predicate is called a  type assertion. Type assertions on a <code>PatVar</code>, will match if and only if  the type of the matched term for the pattern variable is a subtype of <code>T</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Patterns.jl#L31-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.isground-Tuple{AbstractPat}" href="#Metatheory.Patterns.isground-Tuple{AbstractPat}"><code>Metatheory.Patterns.isground</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A ground pattern contains no pattern variables and  only literal values to match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Patterns.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Patterns.patvars-Tuple{PatVar, Any}" href="#Metatheory.Patterns.patvars-Tuple{PatVar, Any}"><code>Metatheory.Patterns.patvars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Collects pattern variables appearing in a pattern into a vector of symbols</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Patterns.jl#L102-L104">source</a></section></article><hr/><h2 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.DynamicRule" href="#Metatheory.Rules.DynamicRule"><code>Metatheory.Rules.DynamicRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules defined as <code>left_hand =&gt; right_hand</code> are called <code>dynamic</code> rules. Dynamic rules behave like anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>=&gt;</code> rule is evaluated during rewriting: matched values are bound to pattern variables as in a regular function call. This allows for dynamic computation of right hand sides.</p><p>Dynamic rule</p><pre><code class="language-julia">@rule ~a::Number * ~b::Number =&gt; ~a*~b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Rules.jl#L160-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.EqualityRule" href="#Metatheory.Rules.EqualityRule"><code>Metatheory.Rules.EqualityRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>EqualityRule</code> can is a symbolic substitution rule that  can be rewritten bidirectional. Therefore, it should only be used  with the EGraphs backend.</p><pre><code class="language-julia">@rule ~a * ~b == ~b * ~a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Rules.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.RewriteRule" href="#Metatheory.Rules.RewriteRule"><code>Metatheory.Rules.RewriteRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules defined as <code>left_hand --&gt; right_hand</code> are called <em>symbolic rewrite</em> rules. Application of a <em>rewrite</em> Rule is a replacement of the <code>left_hand</code> pattern with the <code>right_hand</code> substitution, with the correct instantiation of pattern variables. Function call symbols are not treated as pattern variables, all other identifiers are treated as pattern variables. Literals such as <code>5, :e, &quot;hello&quot;</code> are not treated as pattern variables.</p><pre><code class="language-julia">@rule ~a * ~b --&gt; ~b * ~a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Rules.jl#L37-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rules.UnequalRule" href="#Metatheory.Rules.UnequalRule"><code>Metatheory.Rules.UnequalRule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This type of <em>anti</em>-rules is used for checking contradictions in the EGraph backend. If two terms, corresponding to the left and right hand side of an <em>anti-rule</em> are found in an [<code>EGraph</code>], saturation is halted immediately. </p><pre><code class="language-julia">!a ≠ a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Rules.jl#L126-L135">source</a></section></article><hr/><h2 id="Rules-2"><a class="docs-heading-anchor" href="#Rules-2">Rules</a><a class="docs-heading-anchor-permalink" href="#Rules-2" title="Permalink"></a></h2><hr/><h2 id="Rewriters"><a class="docs-heading-anchor" href="#Rewriters">Rewriters</a><a id="Rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rewriters" href="#Metatheory.Rewriters"><code>Metatheory.Rewriters</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A rewriter is any function which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression.</p><p>The <code>Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it retuns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. Note that if  <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk.  <code>threaded=true</code> will use multi threading for traversal. <code>thread_cutoff</code> is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>FixpointNoCycle</code> behaves like <a href="@ref"><code>Fixpoint</code></a> but instead it applies <code>rw</code> repeatedly only while it is returning new results.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul><hr/><p><strong>Imports</strong></p><ul><li><code>Base</code></li><li><code>Base.Threads</code></li><li><code>Core</code></li><li><code>TermInterface</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Rewriters.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.Rewriters.FixpointNoCycle" href="#Metatheory.Rewriters.FixpointNoCycle"><code>Metatheory.Rewriters.FixpointNoCycle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FixpointNoCycle(rw)</code></pre><p><code>FixpointNoCycle</code> behaves like <a href="@ref"><code>Fixpoint</code></a>, but returns a rewriter which applies <code>rw</code> repeatedly until  it produces a result that was already produced before, for example,  if the repeated application of <code>rw</code> produces results <code>a, b, c, d, b</code> in order,  <code>FixpointNoCycle</code> stops because <code>b</code> has been already produced. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/Rewriters.jl#L127-L135">source</a></section></article><hr/><h2 id="EGraphs"><a class="docs-heading-anchor" href="#EGraphs">EGraphs</a><a id="EGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#EGraphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.EGraph" href="#Metatheory.EGraphs.EGraph"><code>Metatheory.EGraphs.EGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct EGraph</code></pre><p>A concrete type representing an [<code>EGraph</code>]. See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> for implementation details.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>uf::IntDisjointSet</code></p><p>stores the equality relations over e-class ids</p></li><li><p><code>classes::Dict{Int64, EClass}</code></p><p>map from eclass id to eclasses</p></li><li><p><code>memo::Dict{AbstractENode, Int64}</code></p><p>hashcons</p></li><li><p><code>dirty::Vector{Int64}</code></p><p>worklist for ammortized upwards merging</p></li><li><p><code>root::Int64</code></p></li><li><p><code>analyses::Dict{Union{Function, Symbol}, Union{Function, Symbol}}</code></p><p>A vector of analyses associated to the EGraph</p></li><li><p><code>symcache::Dict{Any, Vector{Int64}}</code></p><p>a cache mapping function symbols to e-classes that contain e-nodes with that function symbol.</p></li><li><p><code>default_termtype::Type</code></p></li><li><p><code>termtypes::Dict{Tuple{Any, Int64}, Type}</code></p></li><li><p><code>numclasses::Int64</code></p></li><li><p><code>numnodes::Int64</code></p></li><li><p><code>needslock::Bool</code></p><p>If we use global buffers we may need to lock. Defaults to true.</p></li><li><p><code>buffer::Vector{Base.ImmutableDict{Int64, Tuple{Int64, Int64}}}</code></p><p>Buffer for e-matching which defaults to a global. Use a local buffer for generated functions.</p></li><li><p><code>merges_buffer::Vector{Tuple{Int64, Int64}}</code></p><p>Buffer for rule application which defaults to a global. Use a local buffer for generated functions.</p></li><li><p><code>lock::ReentrantLock</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.EGraph-Tuple{}" href="#Metatheory.EGraphs.EGraph-Tuple{}"><code>Metatheory.EGraphs.EGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EGraph(expr)</code></pre><p>Construct an EGraph from a starting symbolic expression <code>expr</code>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">EGraph() -&gt; EGraph
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">EGraph()</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L212"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:212</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.EqualityGoal" href="#Metatheory.EGraphs.EqualityGoal"><code>Metatheory.EGraphs.EqualityGoal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EqualityGoal &lt;: SaturationGoal</code></pre><p>This goal is reached when the <code>exprs</code> list of expressions are in the  same equivalence class.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>exprs::Vector{Any}</code></p></li><li><p><code>ids::Vector{Int64}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.FunctionGoal" href="#Metatheory.EGraphs.FunctionGoal"><code>Metatheory.EGraphs.FunctionGoal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FunctionGoal &lt;: SaturationGoal</code></pre><p>Boolean valued function as an arbitrary saturation goal. User supplied function must take an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> as the only parameter.</p><hr/><p><strong>Fields</strong></p><ul><li><code>fun::Function</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.SaturationParams" href="#Metatheory.EGraphs.SaturationParams"><code>Metatheory.EGraphs.SaturationParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SaturationParams</code></pre><p>Configurable Parameters for the equality saturation process.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>timeout::Int64</code></p></li><li><p><code>timelimit::UInt64</code></p><p>Timeout in nanoseconds</p></li><li><p><code>eclasslimit::Int64</code></p><p>Maximum number of eclasses allowed</p></li><li><p><code>enodelimit::Int64</code></p></li><li><p><code>goal::Union{Nothing, SaturationGoal}</code></p></li><li><p><code>stopwhen::Function</code></p></li><li><p><code>scheduler::Type{&lt;:Metatheory.EGraphs.Schedulers.AbstractScheduler}</code></p></li><li><p><code>schedulerparams::Tuple</code></p></li><li><p><code>threaded::Bool</code></p></li><li><p><code>timer::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{EGraph, Int64, Int64}" href="#Base.merge!-Tuple{EGraph, Int64, Int64}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and two e-class ids, set the two e-classes as equal.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">merge!(g::EGraph, a::Int64, b::Int64) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">merge!(g, a, b)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L391"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:391</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.add!-Tuple{EGraph, AbstractENode}" href="#Metatheory.EGraphs.add!-Tuple{EGraph, AbstractENode}"><code>Metatheory.EGraphs.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inserts an e-node in an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">add!(g::EGraph, n::AbstractENode) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">add!(g, n)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L315"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:315</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.addexpr!-Tuple{EGraph, Any}" href="#Metatheory.EGraphs.addexpr!-Tuple{EGraph, Any}"><code>Metatheory.EGraphs.addexpr!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recursively traverse an type satisfying the <code>TermInterface</code> and insert terms into an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. If <code>e</code> has no children (has an arity of 0) then directly insert the literal into the <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">addexpr!(g::EGraph, se) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">addexpr!(g, se)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L365"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:365</code></a>.</p><pre><code class="language-julia">addexpr!(g, ec)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L382"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:382</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.analyze!-Tuple{EGraph, Any, Vector{Int64}}" href="#Metatheory.EGraphs.analyze!-Tuple{EGraph, Any, Vector{Int64}}"><code>Metatheory.EGraphs.analyze!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">analyze!(egraph, analysis_name, [ECLASS_IDS])</code></pre><p>Given an <a href="@ref">EGraph</a> and an <code>analysis</code> identified by name <code>analysis_name</code>,  do an automated bottom up trasversal of the EGraph, associating a value from the  domain of analysis to each ENode in the egraph by the <a href="@ref">make</a> function.  Then, for each <a href="@ref">EClass</a>, compute the <a href="@ref">join</a> of the children ENodes analyses values. After <code>analyze!</code> is called, an analysis value will be associated to each EClass in the EGraph. One can inspect and retrieve analysis values by using <a href="@ref">hasdata</a> and <a href="@ref">getdata</a>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">analyze!(g::EGraph, analysis_ref, ids::Vector{Int64}) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">analyze!(g, analysis_ref, ids)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L61"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:61</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.astsize-Tuple{ENodeTerm, EGraph}" href="#Metatheory.EGraphs.astsize-Tuple{ENodeTerm, EGraph}"><code>Metatheory.EGraphs.astsize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A basic cost function, where the computed cost is the size (number of children) of the current expression.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">astsize(n::ENodeTerm, g::EGraph) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">astsize(n, g)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L98"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:98</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.astsize_inv-Tuple{ENodeTerm, EGraph}" href="#Metatheory.EGraphs.astsize_inv-Tuple{ENodeTerm, EGraph}"><code>Metatheory.EGraphs.astsize_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">astsize_inv(n::ENodeTerm, g::EGraph) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">astsize_inv(n, g)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L115"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:115</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.egraph_reconstruct_expression-Tuple{Type{Expr}, Any, Any}" href="#Metatheory.EGraphs.egraph_reconstruct_expression-Tuple{Type{Expr}, Any, Any}"><code>Metatheory.EGraphs.egraph_reconstruct_expression</code></a> — <span class="docstring-category">Method</span></header><section><div><p>When extracting symbolic expressions from an e-graph, we need  to instruct the e-graph how to rebuild expressions of a certain type.  This function must be extended by the user to add new types of expressions that can be manipulated by e-graphs.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">egraph_reconstruct_expression(T::Type{Expr}, op, args) -&gt; Expr
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">egraph_reconstruct_expression(T, op, args)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L534"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:534</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.eqsat_search!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Metatheory.EGraphs.Schedulers.AbstractScheduler, Metatheory.EGraphs.SaturationReport}" href="#Metatheory.EGraphs.eqsat_search!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Metatheory.EGraphs.Schedulers.AbstractScheduler, Metatheory.EGraphs.SaturationReport}"><code>Metatheory.EGraphs.eqsat_search!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns an iterator of <code>Match</code>es.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">eqsat_search!(g::EGraph, theory::Vector{&lt;:AbstractRule}, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, report::Metatheory.EGraphs.SaturationReport) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">eqsat_search!(g, theory, scheduler, report)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/saturation.jl#L114"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:114</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.eqsat_step!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Any, Metatheory.EGraphs.Schedulers.AbstractScheduler, SaturationParams, Any}" href="#Metatheory.EGraphs.eqsat_step!-Tuple{EGraph, Vector{&lt;:AbstractRule}, Any, Metatheory.EGraphs.Schedulers.AbstractScheduler, SaturationParams, Any}"><code>Metatheory.EGraphs.eqsat_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Core algorithm of the library: the equality saturation step.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">eqsat_step!(g::EGraph, theory::Vector{&lt;:AbstractRule}, curr_iter, scheduler::Metatheory.EGraphs.Schedulers.AbstractScheduler, params::SaturationParams, report) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">eqsat_step!(g, theory, curr_iter, scheduler, params, report)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/saturation.jl#L257"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:257</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.extract!-Tuple{EGraph, Function}" href="#Metatheory.EGraphs.extract!-Tuple{EGraph, Function}"><code>Metatheory.EGraphs.extract!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a cost function, extract the expression with the smallest computed cost from an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">extract!(g::EGraph, costfun::Function) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">extract!(g, costfun)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L163"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:163</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.find-Tuple{EGraph, Int64}" href="#Metatheory.EGraphs.find-Tuple{EGraph, Int64}"><code>Metatheory.EGraphs.find</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the canonical e-class id for a given e-class.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">find(g::EGraph, a::Int64) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">find(g, a)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L272"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:272</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.instantiate_actual_param!-Tuple{Base.ImmutableDict{Int64, Tuple{Int64, Int64}}, EGraph, Any}" href="#Metatheory.EGraphs.instantiate_actual_param!-Tuple{Base.ImmutableDict{Int64, Tuple{Int64, Int64}}, EGraph, Any}"><code>Metatheory.EGraphs.instantiate_actual_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Instantiate argument for dynamic rule application in e-graph</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">instantiate_actual_param!(bindings::Base.ImmutableDict{Int64, Tuple{Int64, Int64}}, g::EGraph, i) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">instantiate_actual_param!(bindings, g, i)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/saturation.jl#L194"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:194</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.islazy-Union{Tuple{Val{analysis_name}}, Tuple{analysis_name}} where analysis_name" href="#Metatheory.EGraphs.islazy-Union{Tuple{Val{analysis_name}}, Tuple{analysis_name}} where analysis_name"><code>Metatheory.EGraphs.islazy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">islazy(::Val{analysis_name})</code></pre><p>Should return <code>true</code> if the EGraph Analysis <code>an</code> is lazy and false otherwise. A <em>lazy</em> EGraph Analysis is computed  only when <a href="@ref">analyze!</a> is called. <em>Non-lazy</em>  analyses are instead computed on-the-fly every time ENodes are added to the EGraph or EClasses are merged.  </p><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">islazy(_)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L14"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:14</code></a>.</p><pre><code class="language-julia">islazy(analysis_name)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L15"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:15</code></a>.</p><pre><code class="language-julia">islazy(_)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L135"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:135</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.join-Union{Tuple{analysis_name}, Tuple{Val{analysis_name}, Any, Any}} where analysis_name" href="#Metatheory.EGraphs.join-Union{Tuple{analysis_name}, Tuple{Val{analysis_name}, Any, Any}} where analysis_name"><code>Metatheory.EGraphs.join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">join(::Val{analysis_name}, a, b)</code></pre><p>Joins two analyses values into a single one, used by <a href="@ref">analyze!</a> when two eclasses are being merged or the analysis is being constructed.</p><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">join(analysis, a, b)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L35"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:35</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.make-Tuple{Function, EGraph, AbstractENode}" href="#Metatheory.EGraphs.make-Tuple{Function, EGraph, AbstractENode}"><code>Metatheory.EGraphs.make</code></a> — <span class="docstring-category">Method</span></header><section><div><p>When passing a function to analysis functions it is considered as a cost function</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">make(f::Function, g::EGraph, n::AbstractENode) -&gt; Tuple{AbstractENode, Any}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">make(f, g, n)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L131"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:131</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.make-Union{Tuple{analysis_name}, Tuple{Val{analysis_name}, Any, Any}} where analysis_name" href="#Metatheory.EGraphs.make-Union{Tuple{analysis_name}, Tuple{Val{analysis_name}, Any, Any}} where analysis_name"><code>Metatheory.EGraphs.make</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make(::Val{analysis_name}, g, n)</code></pre><p>Given an ENode <code>n</code>, <code>make</code> should return the corresponding analysis value. </p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">make(_::Val{analysis_name}, g, n)
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">make(_, g, n)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L44"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:44</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.modify!-Union{Tuple{analysis_name}, Tuple{Val{analysis_name}, Any, Any}} where analysis_name" href="#Metatheory.EGraphs.modify!-Union{Tuple{analysis_name}, Tuple{Val{analysis_name}, Any, Any}} where analysis_name"><code>Metatheory.EGraphs.modify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">modify!(::Val{analysis_name}, g, id)</code></pre><p>The <code>modify!</code> function for EGraph Analysis can optionally modify the eclass <code>g[id]</code> after it has been analyzed, typically by adding an ENode. It should be <strong>idempotent</strong> if no other changes occur to the EClass.  (See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a>).</p><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">modify!(_, g, id)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/analysis.jl#L25"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:25</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/analysis.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.preprocess-Tuple{Expr}" href="#Metatheory.EGraphs.preprocess-Tuple{Expr}"><code>Metatheory.EGraphs.preprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extend this function on your types to do preliminary preprocessing of a symbolic term before adding it to  an EGraph. Most common preprocessing techniques are binarization of n-ary terms and metadata stripping.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">preprocess(e::Expr) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">preprocess(e)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L355"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:355</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.reachable-Tuple{EGraph, Int64}" href="#Metatheory.EGraphs.reachable-Tuple{EGraph, Int64}"><code>Metatheory.EGraphs.reachable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Recursive function that traverses an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and returns a vector of all reachable e-classes from a given e-class id.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">reachable(g::EGraph, id::Int64) -&gt; Vector{Int64}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">reachable(g, id)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L501"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:501</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.rebuild!-Tuple{EGraph}" href="#Metatheory.EGraphs.rebuild!-Tuple{EGraph}"><code>Metatheory.EGraphs.rebuild!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function restores invariants and executes upwards merging in an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> for more details.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">rebuild!(g::EGraph) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">rebuild!(g)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/egraph.jl#L426"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egraph.jl:426</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/egraph.jl#L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.saturate!" href="#Metatheory.EGraphs.saturate!"><code>Metatheory.EGraphs.saturate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given an <a href="#Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and a collection of rewrite rules, execute the equality saturation algorithm.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">saturate!(g::EGraph, theory::Vector{&lt;:AbstractRule}) -&gt; Metatheory.EGraphs.SaturationReport
saturate!(g::EGraph, theory::Vector{&lt;:AbstractRule}, params) -&gt; Metatheory.EGraphs.SaturationReport
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">saturate!(g, theory)
saturate!(g, theory, params)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/saturation.jl#L286"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:286</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/saturation.jl#L282">source</a></section></article><hr/><h2 id="EGraph-Schedulers"><a class="docs-heading-anchor" href="#EGraph-Schedulers">EGraph Schedulers</a><a id="EGraph-Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#EGraph-Schedulers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.AbstractScheduler" href="#Metatheory.EGraphs.Schedulers.AbstractScheduler"><code>Metatheory.EGraphs.Schedulers.AbstractScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractScheduler</code></pre><p>Represents a rule scheduler for the equality saturation process</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.BackoffScheduler" href="#Metatheory.EGraphs.Schedulers.BackoffScheduler"><code>Metatheory.EGraphs.Schedulers.BackoffScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct BackoffScheduler &lt;: Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.</p><p>This seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>data::IdDict{AbstractRule, Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}</code></p></li><li><p><code>G::EGraph</code></p></li><li><p><code>theory::Vector{&lt;:AbstractRule}</code></p></li><li><p><code>curr_iter::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.ScoredScheduler" href="#Metatheory.EGraphs.Schedulers.ScoredScheduler"><code>Metatheory.EGraphs.Schedulers.ScoredScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ScoredScheduler &lt;: Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.</p><p>This seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>data::IdDict{AbstractRule, Metatheory.EGraphs.Schedulers.ScoredSchedulerEntry}</code></p></li><li><p><code>G::EGraph</code></p></li><li><p><code>theory::Vector{&lt;:AbstractRule}</code></p></li><li><p><code>curr_iter::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.SimpleScheduler" href="#Metatheory.EGraphs.Schedulers.SimpleScheduler"><code>Metatheory.EGraphs.Schedulers.SimpleScheduler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SimpleScheduler &lt;: Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A simple Rewrite Scheduler that applies every rule every time</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.cansaturate" href="#Metatheory.EGraphs.Schedulers.cansaturate"><code>Metatheory.EGraphs.Schedulers.cansaturate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Should return <code>true</code> if the e-graph can be said to be saturated</p><pre><code class="language-none">cansaturate(s::AbstractScheduler)</code></pre><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L63"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:63</code></a>.</p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L120"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:120</code></a>.</p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L231"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:231</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.cansearch" href="#Metatheory.EGraphs.Schedulers.cansearch"><code>Metatheory.EGraphs.Schedulers.cansearch</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Should return <code>false</code> if the rule <code>r</code> should be skipped</p><pre><code class="language-none">cansearch(s::AbstractScheduler, r::Rule)</code></pre><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">cansearch(s, r)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L64"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:64</code></a>.</p><pre><code class="language-julia">cansearch(s, r)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L100"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:100</code></a>.</p><pre><code class="language-julia">cansearch(s, r)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L169"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:169</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Metatheory.EGraphs.Schedulers.inform!" href="#Metatheory.EGraphs.Schedulers.inform!"><code>Metatheory.EGraphs.Schedulers.inform!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>This function is called <strong>after</strong> pattern matching on the e-graph, informs the scheduler about the yielded matches. Returns <code>false</code> if the matches should not be yielded and ignored. </p><pre><code class="language-none">inform!(s::AbstractScheduler, r::AbstractRule, n_matches)</code></pre><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">inform!(s, r, n_matches)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L68"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:68</code></a>.</p><pre><code class="language-julia">inform!(s, rule, n_matches)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L123"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:123</code></a>.</p><pre><code class="language-julia">inform!(s, rule, n_matches)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/Metatheory.jl/tree/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef//src/EGraphs/Schedulers.jl#L234"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers.jl:234</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Metatheory.jl/blob/0cff9124de7b348ea4c86817b663d7f6cfc8a9ef/src/EGraphs/Schedulers.jl#L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../visualizing/">« Visualizing E-Graphs</a><a class="docs-footer-nextpage" href="../tutorials/custom_types/">Interfacing with Metatheory.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 December 2023 09:39">Thursday 7 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
